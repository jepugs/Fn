(defn reverse (list)
  (letfn iter (acc rem)
    (if (empty? rem)
        acc
        (iter (cons (head rem) acc) (tail rem))))
  (iter [] list))

(defn map (f list)
  (reverse (maprev f list)))

; map, but returns reversed list. This is faster than map
(defn maprev (f list)
  (letfn iter (acc rem)
    (if (empty? rem)
        acc
        (iter (cons (f (head rem)) acc)
              (tail rem))))
  (iter [] list))

; map, but rather than creating a list, just returns nil
(defn mapnil (f list)
  (if (empty? list)
      nil
      (do
        (f (head list))
        (mapnil f (tail list)))))


(defn filter (pred list)
  (letfn iter (acc rem)
    (cond
      (empty? rem) (reverse acc)
      (pred (head rem)) (iter (cons (head rem) acc)
                              (tail rem))
      true (iter acc (tail rem))))
  (iter [] list))

; someone went and added this one to the builtins!

; (defn concat (& lists)
;   (letfn cat2 (l1 l2)
;     (letfn a2-iter (acc rem)
;       (if (empty? rem)
;           acc
;           (a2-iter (cons (head rem) acc)
;                    (tail rem))))
;     (a2-iter l2 (reverse l1)))
;   (letfn iter (acc rem)
;     (if (empty? rem)
;         acc
;         (iter (cat2 acc (head rem))
;               (tail rem))))
;   (iter [] lists))

(defn foldl (f init list)
  (letfn iter (acc rem)
         (if (empty? rem)
             acc
           (iter (f acc (head rem)) (tail rem))))
  (iter init list))

(defn foldr (f init list)
  (letfn iter (acc rem)
    (if (empty? rem)
        acc
        (iter (f (head rem) acc) (tail rem))))
  (iter init (reverse list)))

(defn replace-at (list pos new)
  (if (= pos 0)
      (cons new (tail list))
      (cons (head list)
            (replace-at (tail list) (- pos 1) new))))

(defn list-range (start stop (step 1))
  ; this actually builds the range in reverse
  (def cmp (if (< step 0) < >)) ; comparison depends on sign of step
  (defn iter (acc i)
    (if (cmp i start)
        acc
        (iter (cons i acc) (- i step))))
  (iter [] start))

;; implementation of apply as a function
(defn apply (fun arg0 arg1 & args)
  (letfn iter (acc rem)
    (if (empty? (tail (tail rem)))
        [(concat (reverse acc) (head rem))
         (head (tail rem))]
        (iter (cons (head rem) acc)
              (tail rem))))
  (let result (iter [] (cons arg0 (cons arg1 args))))
  (apply fun (nth 0 result) (nth 1 result)))



;; syntax: for var in list do
;;         while expr do
(defmacro loop (cmd & args)
  (cond
    (= cmd 'while) (do
                     (let expr (head args)
                          body (tail (tail args)))
                     `(do
                        (letfn __lp (val)
                            (if ,expr
                                (__lp (do ,@body))
                                val))
                        (__lp nil)))
    true 'nil))
