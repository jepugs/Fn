#+title: Fn Language Specification
#+author: Jack Pugmire

:preamble:
#+latex_header: \usepackage{amsmath}
#+latex_header: \newcommand{\FnObj}{\text{FnObj}}
#+latex_header: \newcommand{\List}{\text{List}}
#+latex_header: \newcommand{\Function}{\text{Function}}
#+latex_header: \newcommand{\Namespace}{\text{Namespace}}
#+latex_header: \newcommand{\Symbol}{\text{Symbol}}
#+latex_header: \newcommand{\Ident}{\text{Ident}}
#+latex_header: \newcommand{\Keyw}{\text{Keyw}}
#+latex_header: \newcommand{\Reserv}{\text{Reserv}}
#+latex_header: \newcommand{\Err}{\text{Err}}
#+latex_header: \newcommand{\Error}{\text{Error}}
#+latex_header: \newcommand{\Result}{\text{Result}}
#+latex_header: \newcommand{\Expr}{\text{Expr}}
#+latex_header: \newcommand{\Env}{\text{Env}}
#+latex_header: \newcommand{\Clos}{\text{Clos}}
#+latex_header: \newcommand{\Glob}{\text{Glob}}
#+latex_header: \newcommand{\symb}[1]{\texttt{'{#1}}}
#+latex_header: \newcommand{\Nothing}{\text{Nothing}}
#+latex_header: \newcommand{\N}{\mathbb{N}}
# math operators for structures, sequences, and KV-stores
#+latex_header: \DeclareMathOperator{\Len}{Len}
#+latex_header: \DeclareMathOperator{\Extend}{Extend}
#+latex_header: \DeclareMathOperator{\Seq}{Seq}
#+latex_header: \DeclareMathOperator{\KV}{KV}
#+latex_header: \DeclareMathOperator{\Bind}{Bind}
#+latex_header: \DeclareMathOperator{\Bound}{Bound}
#+latex_header: \DeclareMathOperator{\Lookup}{Lookup}
#+latex_header: \DeclareMathOperator{\Resolve}{Resolve}
#+latex_header: \DeclareMathOperator{\Eval}{Eval}

# unfortunately don't have a better way to do this except for copying the exports for mathjax.
#+begin_export html
<div style="display: none">
\(
\newcommand{\FnObj}{\text{FnObj}}
\newcommand{\List}{\text{List}}
\newcommand{\Function}{\text{Function}}
\newcommand{\Namespace}{\text{Namespace}}
\newcommand{\Symbol}{\text{Symbol}}
\newcommand{\Ident}{\text{Ident}}
\newcommand{\Keyw}{\text{Keyw}}
\newcommand{\Reserv}{\text{Reserv}}
\newcommand{\Err}{\text{Err}}
\newcommand{\Error}{\text{Error}}
\newcommand{\Result}{\text{Result}}
\newcommand{\Expr}{\text{Expr}}
\newcommand{\Env}{\text{Env}}
\newcommand{\Glob}{\text{Glob}}
\newcommand{\symb}[1]{\texttt{'{#1}}}
\newcommand{\Nothing}{\text{Nothing}}
\newcommand{\N}{\mathbb{N}}
\DeclareMathOperator{\Seq}{Seq}
\DeclareMathOperator{\Len}{Len}
\DeclareMathOperator{\Extend}{Extend}
\DeclareMathOperator{\KV}{KV}
\DeclareMathOperator{\Bind}{Bind}
\DeclareMathOperator{\Bound}{Bound}
\DeclareMathOperator{\Lookup}{Lookup}
\DeclareMathOperator{\Resolve}{Resolve}
\DeclareMathOperator{\Eval}{Eval}
\)
</div>
#+end_export
:end:

* About this Document

This document is a minimal formal spec of fn for Version 0.1.0. The goal is to completely describe
fn without any ambiguity so that it may be implemented precisely, with no undefined behavior. It is
meant mainly as an aid to the implementor.


* Lexical Analysis

The component which processes Fn source into lexical tokens is called the
*scanner*. Conceptually, we put in a sequence of bytes and get back a sequence
of tokens.

Tokens are dividide into two groups: fixed width and variable width. The fixed
width tokens are:
- '(' :: left paren
- ')' :: right paren
- '[' :: left bracket
- ']' :: right bracket
- '{' :: left brace
- '}' :: right brace
- '\'' :: quote
- '`' :: backtick
- ',@' :: comma at
- ',' :: comma
- '$`' :: dollar backtick
- '$(' :: dollar paren
- '$[' :: dollar bracket
- '${' :: dollar brace

Fixed width tokens are generated when the scanner encounters one of the
corresponding quoted strings above.

Variable width tokens are:
- <number> :: numeric literal
- <string> :: string literal
- <symbol> :: symbol
- <dot> :: dot expression (2 or more symbols separated by '.')

** Comments

A comment begins when the unescaped character ~';'~ is encountered outside a
string. Comments end at the end of the line.

** Numbers, Symbols, and Dots

Numbers are defined according to regular expressions as in the following
pseudo-BNF grammar:

#+begin_src
<number> ::= "[+-]?(<dec>|<hex>)"
<dec>    ::= "[0-9]+\.?<exp>?"
           | "[0-9]*\.[0-9]+<exp>?"
<exp>    ::= "[eE][+-]?[0-9]+"
<hex>    ::= "0[Xx][0-9A-Fa-f]+\.?"
           | "0[Xx][0-9A-Fa-f]*\.[0-9A-Fa-f]"
#+end_src

A symbol is defined to be a sequence of symbol characters and escaped characters
which is not a number. Symbol characters are all printable ASCII characters
other than whitespace or those contained in the string ~";(){}[]\"\\'`,."~. An
escaped character is a sequence of two characters, the escape ~'\\'~ followed by
an arbitrary character. When the symbol is internalized, the escape character is
ignored, so its name will contain only the second character of the escape
sequence.

If an escape character is followed by EOF, a scanning error is raised.

Note that by injecting an escape character, one may cause numbers to be treated
as symbols. Adding an escape in front of any normal character normally no
effect, but in this case, it causes the number reader to fail, so the number's
characters will read as a symbol.

Finally, a dot token is a symbol token which contains the dot character ~'.'~,
subject to some additional restrictions. Dots can not occur in the first or last
position of the string, and it can not contain successive dots. In addition, the
substring before the first dot may not be a syntactically valid number. If any
of these conditions is violated, a scanning error is raised.

** TODO String Literals

String scanning starts when the scanner encounters the (unescaped) character
~'"'~ and ends when it encounters an unescaped ~'"'~. Along the way, all bytes
encountered are read verbatim, except for the escape character '\\', which is
followed by an escape sequence. The entire escape sequence is read into the
string according to the following table [fn:c-string-escapes]:
- '\'' :: single quote
- '\"' :: double quote
- '\?' :: question mark
- '\a' :: ASCII bell
- '\b' :: backspace
- '\f' :: form feed
- '\n' :: newline
- '\r' :: ASCII carriage return
- '\t' :: tab
- '\v' :: vertical tab
- '\NNN' (NNN is a 1- to 3- digit octal number) :: byte NNN (octal)
- '\xNN' (NN any two-digit hex number) :: the byte NN (hexadecimal)
- '\uC' (C any 4-digit hex unicode code point) :: unicode code point (2 bytes)
- '\UC' (C any 8-digit hex unicode code point) :: unicode code point (4 bytes)

[fn:c-string-escapes] These string escapes are mainly the same as the ones in C.

** Source Encoding

Currently, Fn only supports ASCII encoded text files. Behavior on other/extended
encodings is undefined. In the future, Fn will be extended so that UTF-8
characters can appear in strings and symbols.


* Syntax

The goal of this section is to establish the necessary definitions and equivalences so that we may
define fn's semantics at a structural level one step above the raw text of a program.

fn source code directly reflects the abstract syntax tree generated by the parser. The simple
structure allows transparent conversion between language-native data structures and the
interpreter's internal representation of the AST. This conversion operation and its simplicity are
essential to fn's metaprogramming system.

** Atoms and Lists

An fn program consists of a sequence of top-level *syntactic forms*. Whenever we speak of a sequence
of syntactic forms, it is implied that they are separated by whitespace.

There are two types of syntactic forms in fn, namely *lists* and *atoms*. As the name implies, atoms are
syntactic primitives which are indivisible, i.e. they do not contain any subforms. Atoms may be
classified as *numbers*, *strings*, or *symbols*. Number and string atoms represent constant values,
whereas symbols have different meanings depending on the context in which they are used.

Lists consist of a sequence of 0 or more syntactic forms contained within a pair of parentheses.
Nesting of lists is what gives fn code its intrinsic tree structure.

As the term list can also refer to the list data type in fn, we will sometimes use the terms
*syntactic list* or *list object* in order to avoid ambiguity.

The first subform of a list is called the *operator* and the other subforms are the *arguments*.
Evaluation semantics are generally determined by the operator. Notably, certain symbols, termed
*special operators*, are reserved to denote language primitives. These symbols may not be used as
variable names.

Note: Throughout the rest of this section we use the word operator to refer both to syntactic
operators as well as the first subform of a list.

** Canonical forms of fn programs

Any fn program can be represented using only atoms, whitespace, and parentheses (i.e.
whitespace-delimited atoms and lists). Code written in this way is said to be in *expanded canonical
form (ECF)*. Source code is internally expanded into ECF by the parser before evaluation. ECF
directly represents the abstract syntax tree of a program. Syntactic forms which are not in ECF are
said to be *pointy* (because parentheses are nice and curvy and smooth).

Code in ECF can automatically be converted

We also define a *short canonical form* (SCF). We obtain this form by doing the inverse of expansion
whenever possible, e.g. every list beginning with the symbol ~Table~ is rewritten using ~{}~. This is
well-defined because no two distinct pointy syntactic operators can possibly expand into the same
expression, so we have bijective map from forms in ECF to those in SCF.

See [[Sugar]] for a comprehensive description of the different pointy syntactic operators and their
expansions to ECF.

** Symbols

*Symbols* are internalized strings which generally name variables but may also be passed around as a
primitive data using the quote operator. The interpreter maintains a list of all symbols, known as
the symbol *table*.

Symbols consist of a sequence symbol constituent characters, defined to be all ASCII characters
other than whitespace, non-printable characters (e.g. the ASCII bell), or any of the special
syntactic characters ~`'",.(){}[];\~. In addition, the characters ~@$~ are part of digraphs not read as
symbol constituents in certain contexts, (see [[Sugar]]).

We also define three special types of symbols, namely *keywords*, *identifiers*, and *reserved words*.
*Keywords* are symbols who have ~:~ (colon) as the first character of their name (even if it is
escaped). *Reserved words* are symbols with specific names reserved by the language, (see below for a
list). Finally, an *identifier* is a symbol which is not a keyword or a reserved word.

*** Reserved words

A reserved word is a symbol whose name is one of the following:
#+begin_src
&
$
and
apply
case
cond
def
defmacro
do
dot
dollar-fn
false
fn
if
import
let
letmacro
null
or
quasiquote
quote
set
true
unquote
unquote-splice
with
#+end_src

** TODO Non-Symbolic Atoms

*** TODO Numbers

*** TODO Strings

** Escape character

~\~ (backslash) is a universal escape character. Special behavior is defined when a backslash occurs
within a string, see [[Strings]]. Otherwise, it converts whatever character follows it into a symbol
constituent and indicates that the current token should be parsed as a symbol. It should not be
abused. Notably, this enables creation of symbols whose names are numbers or include special syntax
characters.

When the backslash is followed by a character which would be read as a symbol constituent anyway, it
is essentially a dead character which can be removed without any semantic implications to the
parsing of the program.

** Comments

Comments begin with ~;~ (semicolon) and end with a newline character. Comments are treated as
whitespace.

** Sugar

fn provides four prefix operators, denoted by ~`~ (backtick), ~'~ (quote), ~,~ (comma), or ~,@~ (comma-at).
Each of these operators must be followed by an expression. They are expanded to lists of length two
consisting of a special operator followed by the expression. These are converted to ECF via the
following rules:
#+begin_src
'form  -> (quote form)
`form  -> (quasiquote form)
,form  -> (unquote form)
,@form -> (unquote-splice form)
#+end_src

In addition to parentheses, fn defines matched delimiters ~{}~ and ~[]~ which may contain any number of
subforms, say n. They are expanded to lists of length (n+1) by prepending a specific symbol:
#+begin_src
[form*] -> (List form*)
{form*} -> (Table form*)
#+end_src

The character ~$~ (dollar) is a special prefix character. When it is immediately followed (i.e., with
no whitespace) by an opening delimiter or certain prefix characters (those other than comma or
comma-at), then it expands like the other prefix with the ~dollar-fn~ special operator:
#+begin_src
$(form*) -> (dollar-fn (form*))
$[form*] -> (dollar-fn (form*))
$'form   -> (dollar-fn 'form)
$`form   -> (dollar-fn `form)
#+end_src

When dollar is immediately followed by comma or comma-at, an error is raised.

The character ~.~ (dot) may only occur between two symbols. There may be no whitespace separating the
dot from the symbols. A form consisting of two or more symbols delimited by dots is called a *dotted
symbol*. These are expanded with the ~dot~ special operator in the following way
#+begin_src
a.b      -> (dot a b)
a.b.c    -> (dot a b c)
a.d.b.d  -> (dot a b c d)
#+end_src


* TODO Data Model

Every value in Fn is an *object*. All objects have a single *type*, which
describes the contents of the object as well as the supported operations. The
types of objects are:

- number :: floating point number (62 bits)
- string :: sequence of bytes. Max length 2^32-1
- symbol :: internalized string
- bool :: special constants true and false
- null :: null value
- list :: immutable singley-linked list
- table :: (mutable) generalized key-value store. Keys may be any object
- namespace :: key-value store associating symbols to values. Represents a
  global environment.
- function :: a function object which may be called

While functions and closures can be used to encode very complex data structures,
this sort of thing is generally discouraged because it can make debugging very
difficult. Thus our primary means of structuring data are tables and lists.

Tables can be used to create ad-hoc record data types. In particular, if the
keys of the table are symbols, then dot syntax may be used. For instance,

#+BEGIN_SRC
;; macro for creating constructors. Something like this will be built in
(defmacro make-cxr (class & keys)
  `(fn ,keys
     {,@(map $`(',$ ,$) keys)
      '_class ,class}))

;; how we define a new class: it's just a table
(def Address
  (do
    (let cxr (make-cxr Address street city zip))
    (letn same-city? (this other)
      ;; dot syntax
      (= this.city other.city))
    {'name 'Address
     'on-call cxr
     'same-city? same-city?}))

;; insertion sort routine. Puts in ascending order by zip code
(defn sort-by-zip (addrs)
  (fold (fn (acc in)
          (let [l r] (acc.split-when $(>= $.zip in.zip)))
          (append l [in] r))
        addrs.head
        addrs.tail))
#+END_SRC

The key ~'_class~ is special for tables. Its value, which must be a table if
defined, is called its *class*. When a table 

This behavior does not occur recursively.

Another special key is ~'on-call~. This may contain a function (or another
callable table). When ~'on-call~ has a value in the table or its class, the
resultant

#+begin_src
#+end_src


** Note: Future Additions

Fixnum and bigint data types

Array data type (efficient random access)


* Variable and Namespaces

For our purposes, a *variable* is a place to hold a value which is named by an
identifier. Variables are defined through dedicated language facilities, and
their values may be recalled using their names.

** Global Variables

Global variables may be defined or accessed at any point in the program source.
A runtime error occurs if an attempt is made to access a global variable before
its definition.

Global variables are created using the ~def~ special operator.

Global variables are stored in namespaces. Namespaces exist in a global
hierarchy which is accessible at runtime using the special global variable ~ns~.
See [[Namespace Loading]] for details.

At any given expression in an Fn program, there is understood to be a single
active global namespace. References to global variables made in the expression
are resolved in this namespace.

** Local Variables and Shadowing

Local variables in Fn are managed using the lexical scope semantics typical of
modern programming languages. Local variables may be introduced using the
special operators ~with~ or ~let~. We say a local variable is "in scope" if it is
accessible from a given lexical context in source code (so global variables are
always in scope).

If there are multiple local variables in scope with the same name, then the
variable introduced at the deepest level takes precedent, (rendering those
higher up in scope temporarily inaccessible).

** Namespace Loading

Namespace loading is the process of importing a namespace from an external
source. This is done using the ~import~ operator.

All loaded namespaces are identified by a unique import-designator, determined
on initial import. Successive uses of ~import~ with the same designator (or the
same file name) will not trigger namespace loading.

A file name is provided to ~import~, either as a string or a dot-delimited path
name. (In the latter case, there is an implied ".fn" file extension which is not
typed). The following occurs:
- Find the file by checking directories in the search path (see [[Search Path]]),
  signaling an error if no match is found.
- Evaluate the contents of the file, saving its global namespace.
- Insert the namespace into the "ns" object.
- Create a global variable bound to the imported namespace

*** Search Path

The search path is, by default: "~/.local/lib/fn", "/usr/local/lib/fn",
"/usr/lib/fn" in that order.

String filenames are always resolved relative to the directory containing the
file, (so absolute paths can be provided by beginning the path name with a "/").

** [Future Addition] Dynamically-scoped variables

Dynamic global variables will be added as a feature in a future release of Fn.
These will function very similar to dynamic variables in Common Lisp. The
general design is this:

- Add a special operator called ~def*~ which behaves like ~def~ but defines
  global dynamic variables
- Dynamic variables must have earmuffs around their names. This will be enforced
  by the compiler.
- Dynamic variables may be locally rebound using ~let~ or ~with~.

The main difference between dynamic variables and lexical variables is that when
a function is called, the dynamic variable bindings are forwarded to the callee.
Lexical variables, on the other hand, get "reset" on every function call. This
relationship is perhaps best conceptualized by considering the relationship
between a program's call graph and its AST. When a lexical variable is
introduced in a vertex of the AST, this variable is available precisely to the
vertex's children in the AST. On the other hand, when a dynamic variable is
introduced somewhere in the call graph, it is accessible to all the children in
the call graph.

A program's call graph is generally much more complicated than its AST, (the
call graph is not usually a tree), so misuse of dynamic variables can cause
terrible readability problems.

In practice, dynamic variables are mainly useful for cases where you may want to
provide additional information to a function without extending its parameter
list. Since dynamic variables do not need to be passed explicitly, they are also
useful for situations where we have many independent functions which need the
same information.

A concrete example of why we would want dynamic variables is for plotting
libraries (such as ggplot2 or matplotlib). These libraries are generally very
imperative and involve building a plot one step at a time. At each step, there
are a number of formatting options to pass around, as well as some sort of
global plot object which is mutated. By using dynamic variables, we can avoid
creating a global object and keep formatting options out of the argument list.

#+BEGIN_SRC
;; example: hypothetical plotting library. We use dynamic variables to set up
;; the plotting environment and then plot some data.

(import plot-lib as pl)

(with (pl.*current-plot* (pl.new-plot "title")
       pl.*line-style* 'dashed
       pl.*color-scheme* pl.colors.bright)
  (pl.label-axis x)
  (pl.plot-data my-data))
#+END_SRC


* Expressions

#+begin_src
program ::= expr* expr ::= immediate
        | variable
        | special-form
        | function-call
        | macro-call
#+end_src

** Immediate Expressions and Variables
Syntax:
#+begin_src
immediate ::= boolean 
          | null
          | number
          | string
variable ::= non-special-symbol
#+end_src

An immediate expression is a literal representing a constant value. On
evaluation, immediate expressions immediately return the value they represent.
See [[Syntax]] for information on how immediate expression syntax.

Variables are represented by non-special symbols, (where special symbols are
those naming special forms, boolean values, or null). If there exists a binding
in the current environment for the provided symbol, then its value is returned.
Otherwise an exception is raised.


** Parameter Lists and Argument Destructuring
Before we proceed, we define parameter lists and specify the way argument
processing works in Fn. This is used in specification of special forms and
function and macro calls.

Parameter list syntax:
#+begin_src
param-list ::= req-parameter* opt-parameter*
               [variadic-list-parameter | variadic-table-parameter]
req-parameter ::= identifier
opt-parameter ::= "(" identifier expr ")"
variadic-list-parameter ::= "&" identifier
variadic-table-parameter ::= ":&" identifier
#+end_src

A parameter list is a syntactic form which describes the arguments accepted by a
function or a macro.
- The four types of parameters are: *required*, *optional*, *variadic list*,
  and *variadic table*.
- Associated to each parameter is an identifier, called the parameter's *name*.
- Optional parameters have a *default value*, which is determined by evaluating
  the provided expression (generally this happens at the time of function/macro
  creation).
- Upon function call or macroexpansion, the names from the parameter list are
  bound as variables to corresponding values from an argument list.
- Required and optional variables are each bound to a single argument. Variadic
  list parameters are bound to a list of arguments, and variadic table
  parameters are bound to a table of arguments whose keys are symbols.

Argument list syntax:
#+begin_src
arg-list ::= positional-argument* keyword-argument*
positional-argument ::= form
keyword-argument ::= keyword form
#+end_src

In addition, we require that every keyword argument has a unique keyword.

Argument lists provide values corresponding the the parameters in a parameter
list. Not all argument lists are valid for all parameter lists. When an argument
list is valid for a parameter list, we say that the two are *compatible*.

Compatibility and parameter values are determined simultaneously via a single
algorithm which halts if compatibility fails.
- Create a numbered array of empty slots corresponding to the non-variadic
  parameters
- Fill the first N slots with the values of the positional arguments, where N is
  the number of positional arguments.
- If there are more positional arguments than slots, bind a list of additional
  arguments to the variadic list parameter. At this point, if there is no
  variadic list parameter or if there are keyword arguments, we halt for
  incompatibility.
- Put each keyword argument in the slot for the parameter with that name. If
  there is no corresponding slot and no variadic keyword argument, or if the
  slot is already filled, then we halt for incompatibility. If there is no slot
  but there is a variadic keyword parameter, then we add the argument as an
  entry to that table.
- Fill in any empty slots with default values. Halt for incompatibility if any
  required parameters have unfilled slots.


** Special forms
Special forms are so called because they have different semantics than function
or macro calls.

*** and
Syntax:
#+begin_src
and-expr ::= "(" "and" expr* ")"
#+end_src

Expressions are evaluated one at a time until a logically false value is
encountered, then returns ~false~. If the end of the list is reached, returns
~true~.

*** def
Syntax:
#+begin_src
def-expr ::= "(" "def" identifier expr ")"
         | "(" "def" func-proto expr+")"
func-proto ::= "(" identifier param-list ")"
#+end_src

Create a (global) binding in the current namespace. The first syntax binds the
identifier to the value of the expression. The second syntax creates a function
with the specified name and parameter list and the expressions as its body. In
either case, if the identifier is already bound, an exception is raised.

Returns ~null~.

*** do
Syntax:
#+begin_src
do-expr ::= "(" "do" expr* ")"
#+end_src

Evaluates provided expressions one at a time, returning the value of the last
one, or ~null~ if no expressions are given.

*** dot
Syntax:
#+begin_src
dot-expr ::= symbol "." dot-key
           | "(" "dot" symbol+ ")"
dot-key  ::= symbol | symbol "." dot-key
#+end_src

In addition, when using the inline "." notation, there may not be space between
the dot and the symbols.

The first symbol (leftmost in the inline notation) must name a variable bound to
either a namespace or a table. The next symbol is used as a key to access an
element of the table. If additional symbols are provided, then they are used as
keys to recursively descend into a tree of tables. An exception is raised if one
of the keys is invalid or if an attempt is made to access an object which is
neither a table nor a namespaec.

~dot~ is generally used in the form of dot syntax as a concise way to handle
both namespaces and tables whose keys are symbols.

*** dollar-fn
Syntax:
#+begin_src
dollar-fn-expr ::= "(" "dollar-fn" expr ")"
               | "$(" expr+ ")"
               | "$[" expr+ "]"
               | "${" expr+ "}"
               | "$`" form
#+end_src

Creates an anonymous function which evaluates the provided expression. With the
"$" syntax, this is the expression after the dollar sign. (The only expressions
which may follow are parenthesized forms, quasiquote forms, or list/table
expressions).

Within the provided expression, variables named ~$N~ where N is a nonnegative
integer, are bound to the corresponding positional parameters starting from 0.
In addition, ~$~ is bound to the first parameter ~$0~ and ~$&~ is used for a
variadic parameter.

The parameter list for the created function accepts as many positional
parameters as the highest value of N and a variadic parameter only if ~$&~
appears in the expression. (This is accomplished by performing code-walking,
including macroexpansion, before compiling the ~dollar-fn~).

*** cond
Syntax:
#+begin_src
cond-expr ::= "(" "cond" cond-case+ ")"
cond-case ::= expr expr
#+end_src

For each cond-case, the following is done:
- evaluate the first expression
- if the first expression is logically true, return the value of the second
  expression
- otherwise, proceed to the next cond-case.

If the end of the list is reached, returns ~null~.

*** TODO defmacro
Syntax:
#+begin_src
defmacro-expr ::= "(" "defmacro" macro-proto expr+ ")"
macro-proto ::= "(" identifier param-list ")"
#+end_src

*** if
Syntax:
#+begin_src
if-expr ::= "(" "if" test-expr expr expr ")"
test-expr ::= expr
#+end_src

Evaluates test-expr. If the result is logically true, returns the value of the
second argument, otherwise returns the value of the final argument.

*** import
Syntax:
#+begin_src
import-expr ::= "(" "import" import-designator [identifier]
                    [import-designator] ")"
import-designator ::= dot-expr | string | symbol
#+end_src

Load a namespace and bind it to a global variable. If an identifier is provided,
then that name is used. Otherwise, the variable name is chosen based upon the
kind of import-designator provided:
- if it is a dot form, then the last key in the dot form is used (e.g. ~pkg.lib~
  would give a variable name ~lib~).
- if it is a symbol, the symbol itself is used
- if it is a string, then the stem of the filename is converted to a symbol and
  then used

In addition, if the special identifier ~_~ is used, then no variable is created
(but namespace loading will still occur).

Specifying a second import designator allows the position in ns object to be
controlled.

See [[Namespace Loading]] for information about how files are located.

*** fn
Syntax:
#+begin_src
fn-expr ::= "(" "fn" "(" param-list ")" expr+ ")"
#+end_src

Returns a function object with the provided parameter list and function body. If
the enclosing environment does not already have an associated closure, one is
created. The resulting function's closure ID will be the same as the current
environment.

Functions may only reference local variables which are defined in the local
environment prior to function creation. Mutually recursive functions local can
be defined by putting definitions in a single with or let expression.

*** let
Syntax:
#+begin_src
let-expr ::= "(" "let" let-pair+ ")"
let-pair ::= identifier expr
#+end_src

Extends the current local environment. For each let-pair initially binds the
provided identifier to null. Then, in the order provided, each expression is
evaluated and the binding is updated to the resultant value.

The initial null-binding allows definition of recursive and even mutually
recursive functions. Care must be taken because this null binding will shadow
existing variables with the same name.

Returns null.

*** or
Syntax:
#+begin_src
or-expr ::= "(" "or" expr* ")"
#+end_src

Evaluates provided expressions one at a time until a logically true value is
obtained. Then returns ~true~. If the end of the list is reached, returns ~false~.

*** quasiquote
Syntax:
#+begin_src
quasiquote-expr ::= "`" form
                | "(" "quasiquote" form ")"
#+end_src

First, creates a fn object corresponding to form just like quote. Before
returning the form, the following transformation is done:
- The form is walked like a tree.
- When an unquote-expr is encountered, instead of descending into it, evaluate
  its argument and insert the result into the tree at that point.
- When an unquote-splicing form is encountered, instead of descending into it,
  evaluate its argument. If the result is not a list or if this is root of the
  tree, raise an error. Otherwise, splice the elements of the list inline into
  the tree at this point.
- Along the way, we keep track of all symbols whose names begin with a hash
  character "#". For each unique hash symbol, a single gensym is created, and
  the hash symbols are replaced by the gensyms in the final expansion. For
  example, see the following code snippet:

#+begin_src
`(#sym1 #sym2 #sym2) ; has the same value as
(with (sym1 (gensym)
       sym2 (gensym))
 [sym1 sym2 sym2])
#+end_src
*** quote
Syntax:
#+begin_src
quote-expr ::= "'" form
           | "(" "quote" form ")"
#+end_src

Returns the syntactic form as an fn object (a tree of atoms and lists).

*** unquote
Syntax:
#+begin_src
unquote-expr ::= "," expr
             | "(" "unquote" expr ")"
#+end_src
Emits an error unless encountered within a quasiquote form.

*** unquote-splicing
Syntax:
#+begin_src
unquote-splicing-expr ::= ",@" expr | "(" "unquote-splicing" expr ")"
#+end_src
Emits an error unless encountered within a quasiquote form.

*** TODO set!
Syntax:
#+begin_src
set!-form ::= "(" "set!" place expr ")"
place ::= identifier 
      | dot-expr
      | get-form
get-form ::= "(" "get" expr+ ")"
#+end_src

*** with
Syntax:
#+begin_src
with-expr ::= "(" with-bindings expr+ ")"
with-bindings ::= "(" (id expr)* ")"
#+end_src

Behaves like ~let~, but rather than operating on the enclosing lexical
environment, instead creates a new child environment and adds bindings to that,
then evaluates the provided expressions in the newly created environment.

Note that this is how ~let~ works in most LISP-like languages.


** Function Calls
Syntax:
#+begin_src
function-call ::= "(" func argument-list ")"
#+end_src
where ~func~ may be any expression other than a reserved symbol.

First, the function and then all the argument forms are evaluated from left to
right. Function parameters are assigned values via the rules described in
[[Parameter Lists and Argument Destructuring]].

At this point, the function can be executed. What exactly this means depends on
the function (certain built-in functions, for instance, call external code and
as such are completely opaque to Fn programs). However, for user-defined
functions, we can specify semantics.

Function evaluation means evaluating the function's body expressions in a
certain lexical environment. This lexical environment is created as an extension
of the one in which the function was created, and has a local variable for each
of the function's parameters. (These variables are bound to the values obtained
by evaluating the arguments).


** TODO Macro Calls
Syntax:
#+begin_src
macro-call ::= "(" macro-name form* ")"
macro-name ::= identifier | dot-expr
#+end_src


* TODO Built-in Functions

Primitives:
- apply
- gensym
- get

- Bool
- List
- String
- Table

- bool?
- function?
- list?
- number?
- namespace?
- null?
- string?
- symbol?
- table?

Lists:
- empty?
- cons

Tables:
- has-key?
- table-keys

Strings and Lists (and future sequences, too):
- head
- tail
- nth
- take
- drop
- take-while
- drop-while
- split
- split-when
- partition
- partition-by
- append
- reverse
- insert
- subseq
- dedup (remove duplicates)
- replace

Higher order functions:
- partial
- map
- fold
- filter
- every
- any


* Future Functionality

Features I would like to add:
- integer datatypes (including fixnum)
- docstrings for variables, functions, and macros
- vector/array native datatype
- (maybe) bytes data structure
- (maybe) dynamic variables
- foreign function interface
- built-in packages for I/O (including sockets/IPC), subroutine management, and
  threading


* Old sections (probably won't finish)

These sections are kept in this document for future reference. I won't work on them any more, but
may reuse parts of them in future revisions

** Special forms

#+begin_src
def-form ::= "(" "def" (identifier expression)+ ")"
do-form ::= "(" "do" expression* ")"
let-form ::= "(" "let" (identifier expression)+ ")"
quote-form ::= "(" "quote" syntactic-form ")"
unquote-form ::= "(" "unquote" expression ")"
unquote-splice-form ::= "(" "unquote-splice" expression ")"
with-form ::= "(" "with" "(" (identifier expression)+ ")" expression* ")"
#+end_src

** Quotation/Quasiquotation

quote accepts one argument and returns it as an fn data structure. This is also the primary way to
get symbols as data objects.

quasiquote is similar to quote, except it walks the tree looking for symbols whose names start
with # or unquote- forms. When it encounters a #-symbol, that symbol is remembered and bound to a
gensym. 
- the datum of an unquote form is evaluated and the result inserted into the list returned by
  quasiquote. The object need not necessarily represent a valid syntactic form, but this will cause
  an error if returned from a macro
- the datum of an unquote-splice form is evaluated and must be a list. It will be spliced
  element-wise into the list in which it occurs. An unquote-splice form on the top level of a
  quasiquote will generate an error

** Namespaces and Environments

A *namespace* is a pair $N = (names,bindings)$ with $names \subset \Ident$, $|names|$ finite, and
$bindings$ a map $names \to \FnObj$. $bindings$ is the *binding map* of the namespace. We define the
following functions on namespaces:

\[
\Bind : \Namespace \times \Ident \times \FnObj \to \Namespace
\]
\[
\Bind(N,x,v) = (N.names\cup \{x\},b')
\]
\[\text{where } b'(y) = \left
\begin{cases}
v & y = x \\
N.bindings(y) & y \neq x
\end{cases}\right.
\]

\[
\Bound : \Namespace \times \Ident \to \{0,1\}
\]
\[
\Bound(N,x) = \left\begin{cases}
1 & x \in N.names \\
0 & x \notin N.names
\end{cases}\right.
\]

\[
\Resolve : \Namespace \times \Ident \to \Result
\]
\[
\Resolve(N,x) = \left\begin{cases}
N.bindings(x) & x \in N.names \\
\Err & x \notin N.names
\end{cases}\right.
\]

Env denotes the set of *environments*, which are tuples $(local,parent)$ of namespaces. Conceptually, an
environments consists of a local namespace and a parent namespace. We also define Bind, Bound, and
Resolve on environments.

\[
\Bind : \Env \times \Ident \times \FnObj \to \Namespace
\]
\[
\Bind(E,x,v) = (\Bind(E.local,x,v),E.parent)
\]

\[
\Bound : \Env \times \Ident \to \{0,1\}
\]
\[
\Bound((L,P),x) = \left\begin{cases}
0 & \Bound(L,x) = \Bound(P,x) = 0 \\
1 & \text{otherwise}
\end{cases}\right.
\]

\[
\Resolve : \Env \times \Ident \to \Result
\]
\[
\Resolve((L,P)) = \left\begin{cases}
\Resolve(L,x) & \Bound(L,x) = 1 \\
\Resolve(P,x) & \Bound(L,x) = 0
\end{cases}\right.
\]

I.e. operations on environments happen in the local namespace wherever possible, and fall back to
the parent namespace when necessary. Thus we may think of environments as chains of namespaces.

** Functions

A *parameter* represents a binding created by calling a function object. Parameters consist of an
identifier and a default value:
\[
\text{Param} = \left\{(x,d) : x \in \text{Ident}, d \in\Result \right\}
\]
A default value $d = \Err$ is used to indicate that the parameter is required.

We then define function objects as tuples $(P,C,B)$, where $P$ is a list of parameters, $C$ is a
*closure*, and $B$ is a list of expressions, called the function's *body*. *Closures* are special
global objects which are references to environments[fn:functions1]. When a function is called, the
environment referenced by the closure is updated, so that changes made to local variables referenced
by the function are persistent across multiple calls. In addition, closures may be shared across
multiple functions.

Top-level definitions in fn are immutable. However, by defining global functions which update the
variables in their closures, persistent global state may be created. For example:
#+begin_src
(with (counter 0)
  (def (get-count)
    (set counter (+ 1 counter))
    counter))

(get-count) ; returns 1
(get-count) ; returns 2
#+end_src

This is considered bad style in general, but there are certain circumstances in which it may be
okay. These include:
- memoization of computationally intensive or recursive functions
- updating seeds for PRNG functions
- rare situations in which you must maintain a reference to a single, global hardware resource
Again, it must be emphasized that persistent state should be avoided whenever possible. This is why
you have to go out of your way and use closures to create it. The main reason why mutable local
variables are provided in the first place is for the situations in which mutation leads to more
efficient or straightforward algorithms, not so that global variables can be created.


[fn:functions1] For convenience, we presently consider closures to be a part of the global state
object, even though they are technically internal to the Fn interpreter.



** Objects and Types

 Values in fn are referred to as *objects*. The set of all fn objects is denoted FnObj[fn:fnobj1].
 Every object has associated to it exactly one *type*, which for our purposes is a named set containing
 that object. Thus Fn's types are a collection of disjoint sets which collectively classify all
 objects. Broadly, objects can be separated into two groups depending on their type, namely *atoms* and
 *compound structures*. Atoms are values which may be represented by a single, indivisible syntactic
 unit, whereas compound types can only be defined using more complex syntactic forms.

*** Atomic types

 - Null :: $\{\mathtt{null}\}$, where ~null~ is a special constant indicating no return value.
 - Bool :: $\{\mathtt{true}, \mathtt{false}\}$ where ~true~ and ~false~ are special constants
   representing boolean values.
 - Number :: A set of floating point numbers. In particular, these are 62-bit floating point numers
   formatted as IEEE 754 64-bit floating-point, but with two fewer significand bits. (Not quite
   double precision, but one-and-nine-thousand-three-hundred-seventy-five-ten-thousandths precision).
 - String :: Sequences of bytes with length less than 2^32. Strings do not necessarily contain text.
 - Symbol :: Internalized strings. Symbol is in natural bijection with String, with the associated
   string being called the symbol's *name*.

*** Compound types

 - List :: Finite sequences of objects. Lists must be constructible[fn:fnobj2].
 - Table :: Generalized key-value stores associating objects to objects. Tables must be
   constructible[fn:fnobj2].
 - Function :: A subroutine which accepts arguments and returns a value. Functions may have side
   effects, although the vast majority of function objects in fn are referentially transparent, as
   God intended. Formally, we represent functions as a tuple $(P,E,L)$, where $P$ is a parameter list,
   $E$ is as list of expressions, and $L$ is a local environment. See [[Functions]] for more.
 - Namespace :: A key-value store mapping symbols to values. Namespaces are similar to Tables, but
   have different mutability rules.


[fn:fnobj1] This is a set in the mathematical sense. This is ensured by the constructibility
requirements on Lists, Tables, and Namespaces. In fact, this restriction makes it countable.
[fn:fnobj2] We restrict List and Table to only include *constructible* lists and tables. Constructible
here means that they can be built in finitely many steps using certain primitive operations. These
primitive operations will be defined in full detail in a future version of this spec. For now we say
that they can be built by a terminating fn program.

*** Symbol Notation and Subsets

 Symbols are denoted in monospace font with a single quote proceeding their name, e.g. ~'symbol~. For
 this reason, we will not generally denote symbols

 For convenience, we define the following subsets of Symbol:
 - Keyw is the set of symbols whose names begin with a colon character (:). Elements of this set are
   called *keywords*.
 - Reserv is the set of symbols which name special constants such as true, false, and null, as well
   as other language primitives. Elements of this set are referred to as *reserved words*. See below
   for a full definition.
 - $\Ident = \mathrm{Symbol} \setminus \left(\mathrm{Keyw} \cup \mathrm{Reserv}\right)$.
   Elements of this set are called *identifiers*.

 Full definition of Reserv:
 \begin{align*}
 \Reserv = \{&\symb{\&}, \symb{\$}, \symb{and}, \symb{apply}, \symb{case}, \symb{cond},\symb{def},
 \symb{defmacro},\\
 &\symb{do}, \symb{dot}, \symb{dollar-fn}, \symb{false}, \symb{fn}, \symb{if}, \symb{import},\\
 &\symb{let},\symb{null}, \symb{or}, \symb{quasiquote}, \symb{quote}, \symb{set}, \symb{true},\\
 &\symb{unquote},\symb{unquote-splice}, \symb{with} \}
 \end{align*}


