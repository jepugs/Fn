* About this Document

This document is a minimal formal spec of fn for Version 0.1.0. The goal is to completely describe
fn without any ambiguity so that it may be implemented precisely, with no undefined behavior. It is
meant mainly as an aid to the implementor.

* Syntax

The goal of this section is to establish the necessary definitions and equivalences so that we may
define fn's semantics at a structural level one step above the raw text of a program.

fn source code directly reflects the abstract syntax tree generated by the parser. The simple
structure allows transparent conversion between language-native data structures and the
interpreter's internal representation of the AST. This conversion operation and its simplicity are
essential to fn's metaprogramming system.

** Atoms and Lists

An fn program consists of a sequence of top-level *syntactic forms*. Whenever we speak of a sequence
of syntactic forms, it is implied that they are separated by whitespace.

There are two types of syntactic forms in fn, namely *lists* and *atoms*. As the name implies, atoms are
syntactic primitives which are indivisible, i.e. they do not contain any subforms. Atoms may be
classified as *numbers*, *strings*, or *symbols*. Number and string atoms represent constant values,
whereas symbols have different meanings depending on the context in which they are used.

Lists consist of a sequence of 0 or more syntactic forms contained within a pair of parentheses.
Nesting of lists is what gives fn code its intrinsic tree structure.

As the term list can also refer to the list data type in fn, we will sometimes use the terms
*syntactic list* or *list object* in order to avoid ambiguity.

The first subform of a list is called the *operator* and the other subforms are the *arguments*.
Evaluation semantics are generally determined by the operator. Notably, certain symbols, termed
*special operators*, are reserved to denote language primitives. These symbols may not be used as
variable names.

Note: Throughout the rest of this section we use the word operator to refer both to syntactic
operators as well as the first subform of a list.

** Canonical forms of fn programs

Any fn program can be represented using only atoms, whitespace, and parentheses (i.e.
whitespace-delimited atoms and lists). Code written in this way is said to be in *expanded canonical
form (ECF)*. Source code is internally expanded into ECF by the parser before evaluation. ECF
directly represents the abstract syntax tree of a program. Syntactic forms which are not in ECF are
said to be *pointy* (because parentheses are nice and curvy and smooth).

Code in ECF can automatically be converted

We also define a *short canonical form* (SCF). We obtain this form by doing the inverse of expansion
whenever possible, e.g. every list beginning with the symbol ~Table~ is rewritten using ~{}~. This is
well-defined because no two distinct pointy syntactic operators can possibly expand into the same
expression, so we have bijective map from forms in ECF to those in SCF.

See [[Sugar]] for a comprehensive description of the different pointy syntactic operators and their
expansions to ECF.

** Symbols

*Symbols* are internalized strings which generally name variables but may also be passed around as a
primitive data using the quote operator. The interpreter maintains a list of all symbols, known as
the symbol *table*.

Symbols consist of a sequence symbol constituent characters, defined to be all ASCII characters
other than whitespace, non-printable characters (e.g. the ASCII bell), or any of the special
syntactic characters ~`'",.(){}[];\~. In addition, the characters ~@$~ are part of digraphs not read as
symbol constituents in certain contexts, (see [[Sugar]]).

We also define three special types of symbols, namely *keywords*, *identifiers*, and *reserved words*.
*Keywords* are symbols who have ~:~ (colon) as the first character of their name (even if it is
escaped). *Reserved words* are symbols with specific names reserved by the language, (see below for a
list). Finally, an *identifier* is a symbol which is not a keyword or a reserved word.

*** Reserved words

A reserved word is a symbol whose name is one of the following:
#+begin_src
&
$
and
apply
case
cond
def
defmacro
do
dot
dollar-fn
false
fn
if
import
let
letmacro
null
or
quasiquote
quote
set
true
unquote
unquote-splice
with
#+end_src

** TODO Non-Symbolic Atoms

*** TODO Numbers

*** TODO Strings

** Escape character

~\~ (backslash) is a universal escape character. Special behavior is defined when a backslash occurs
within a string, see [[Strings]]. Otherwise, it converts whatever character follows it into a symbol
constituent and indicates that the current token should be parsed as a symbol. It should not be
abused. Notably, this enables creation of symbols whose names are numbers or include special syntax
characters.

When the backslash is followed by a character which would be read as a symbol constituent anyway, it
is essentially a dead character which can be removed without any semantic implications to the
parsing of the program.

** Comments

Comments begin with ~;~ (semicolon) and end with a newline character. Comments are treated as
whitespace.

** Sugar

fn provides four prefix operators, denoted by ~`~ (backtick), ~'~ (quote), ~,~ (comma), or ~,@~ (comma-at).
Each of these operators must be followed by an expression. They are expanded to lists of length two
consisting of a special operator followed by the expression. These are converted to ECF via the
following rules:
#+begin_src
'form  -> (quote form)
`form  -> (quasiquote form)
,form  -> (unquote form)
,@form -> (unquote-splice form)
#+end_src

In addition to parentheses, fn defines matched delimiters ~{}~ and ~[]~ which may contain any number of
subforms, say n. They are expanded to lists of length (n+1) by prepending a specific symbol:
#+begin_src
[form*] -> (List form*)
{form*} -> (Table form*)
#+end_src

The character ~$~ (dollar) is a special prefix character. When it is immediately followed (i.e., with
no whitespace) by an opening delimiter or certain prefix characters (those other than comma or
comma-at), then it expands like the other prefix with the ~dollar-fn~ special operator:
#+begin_src
$(form*) -> (dollar-fn (form*))
$[form*] -> (dollar-fn (form*))
$'form   -> (dollar-fn 'form)
$`form   -> (dollar-fn `form)
#+end_src

When dollar is immediately followed by comma or comma-at, an error is raised.

The character ~.~ (dot) may only occur between two symbols. There may be no whitespace separating the
dot from the symbols. A form consisting of two or more symbols delimited by dots is called a *dotted
symbol*. These are expanded with the ~dot~ special operator in the following way
#+begin_src
a.b      -> (dot a b)
a.b.c    -> (dot a b c)
a.d.b.d  -> (dot a b c d)
#+end_src


* Special forms

#+begin_src
def-form          ::= "(" "def" (identifier expression)+ ")"
do-form           ::= "(" "do" expression* ")"
let-form          ::= "(" "let" (identifier expression)+ ")"
quote-form        ::= "(" "quote" syntactic-form ")"
unquote-form      ::= "(" "unquote" expression ")"
unquote-splice-form ::= "(" "unquote-splice" expression ")"
with-form         ::= "(" "with" "(" (identifier expression)+ ")" expression* ")"
#+end_src


* Functions

A *function* is a pair consisting of a parameter list (see below) and a sequence of 1 or more
expressions. The expressions are called the *function body*.



* Parameters

Parameters

A *parameter list* is a finite sequence of parameters. The parameter list may also include a variadic
parameter and/or a variadic keyword parameter.

Parameter list grammar:

#+begin_src
param-list        ::=  "(" [pos-param+] end-params ")"
pos-param         ::= identifier 
                    | "(" identifier expression ")"
end-params        ::= [variadic-param] [variadic-kw-param]
                    | [variadic-kw-param] [variadic-param]
variadic-param    ::= "&" identifier
variadic-kw-param ::= ":&" identifier
#+end_src

** Parameter semantics

Every function has *parameters*. Parameters determine
- what arguments the function requires/accepts
- which local variables are bound in the function body

A positional parameter may be identifier or a pair consisting of an identifier and an expression,
referred to as an init form. Functions may have any number (including 0) positional parameters.

A variadic parameter is an identifier preceded by the special symbol ~&~.

There are three types of parameters: positional parameters, variadic parameters, and variadic
keyword parameters. A function may have any number (including 0) of positional parameters and either
0 or 1 of each type of variadic parameter.

Positional parameters may be either an identifier or a pair consisting of an identifier and a 


* Quotation/Quasiquotation

quote accepts one argument and returns it as an fn data structure. This is also the primary way to
get symbols as data objects.

quasiquote is similar to quote, except it walks the tree looking for symbols whose names start
with # or unquote- forms. When it encounters a #-symbol, that symbol is remembered and bound to a
gensym. 
- the datum of an unquote form is evaluated and the result inserted into the list returned by
  quasiquote. The object need not necessarily represent a valid syntactic form, but this will cause
  an error if returned from a macro
- the datum of an unquote-splice form is evaluated and must be a list. It will be spliced
  element-wise into the list in which it occurs. An unquote-splice form on the top level of a
  quasiquote will generate an error
