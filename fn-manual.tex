% Created 2021-11-20 Sat 23:46
% Intended LaTeX compiler: pdflatex
\documentclass[11pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{grffile}
\usepackage{longtable}
\usepackage{wrapfig}
\usepackage{rotating}
\usepackage[normalem]{ulem}
\usepackage{amsmath}
\usepackage{textcomp}
\usepackage{amssymb}
\usepackage{capt-of}
\usepackage{hyperref}
\author{Jack Pugmire}
\date{\today}
\title{Fn Programming Language Manual (pre-0.1)}
\hypersetup{
 pdfauthor={Jack Pugmire},
 pdftitle={Fn Programming Language Manual (pre-0.1)},
 pdfkeywords={},
 pdfsubject={},
 pdfcreator={Emacs 27.2 (Org mode 9.4.4)}, 
 pdflang={English}}
\begin{document}

\maketitle
\tableofcontents


\section{Command Line Interface}
\label{sec:orgd42282c}

All functionality is accessed via that \texttt{fn} command line program.

\subsection{Invocation}
\label{sec:orgabc4d33}

The fn command line tool has the following interface:
\begin{verbatim}
fn [options] sources ...
\end{verbatim}

When invoked without any arguments, a repl is started in namespace fn/user.

The main options are:
\begin{description}
\item[{\texttt{-r}}] Start a REPL after evaluating all sources.
\item[{\texttt{-{}-repl-ns <namespace>}}] Use the specified namespace for the repl, (as opposed
to the default \texttt{fn/user}).
\item[{\texttt{-h}}] Show help and exit.
\end{description}
There are also two more options that are unlikely to be useful for a typical
user:
\begin{description}
\item[{\texttt{-d}}] Print disassembled bytecode after compiling each expression.
\item[{\texttt{-l}}] Print LLIR (low-level intermediate representation) before compiling each
expression.
\end{description}

The sources are files and strings to evaluate. The types of source arguments
are:
\begin{description}
\item[{\texttt{<filename>}}] Evaluate and load an entire file. The package and namespace are
determined automatically (see below).
\item[{\texttt{-{}-eval <string>}}] Evaluate a string in the default namespace, fn/user.
\item[{\texttt{-{}-eval-in <namespace> <string>}}] Evaluate a string in the given namespace.
\item[{\texttt{-{}-eval-file <namespace> <string>}}] Evaluate an entire file in the given
namespace. Note that this overrides the file's package declaration and treats
it as just a sequence of expressions.
\end{description}

When the filename option above is used, package and namespace are determined
based on the file's name and package declaration. The namespace name is set to
the stem of the filename, and the package is set to the one specified in the
file's package declaration. If the file contains no package declaration, it
defaults to using \texttt{fn/user} as the package (e.g. a \texttt{foo.fn} without a package
declaration will be in namespace \texttt{fn/user/foo}).


\subsection{REPL}
\label{sec:orgab6441a}

In addition to running code, additional functionality can be accessed by typing
keywords (i.e. symbols whose names begin with ":"). The available REPL keywords
are:

\begin{description}
\item[{\texttt{:quit}}] quit the interpreter
\item[{\texttt{:ns <namespace>}}] Switch to the given namespace.
\item[{\texttt{:load <filename>}}] Evaluate a file in the current namespace.
\item[{\texttt{:reimport <namespace>}}] Redo a namespace import as if it was for the first
time. Be warned that references to the old namespace are not deleted, so the
two instances of the namespace can get out of sync and cause errors.
\end{description}


\section{Language Guide}
\label{sec:orgd32069b}

\subsection{Overview}
\label{sec:org2d3f66e}

Fn is a dynamically typed, garbage-collected, general-purpose programming
language with Lisp-like syntax. A couple of its defining characteristics are:
\begin{itemize}
\item The core language has relatively few operators, with special care taken to
ensure they have consistent and concise syntax.
\item Fn is designed for a "mostly functional" programming style, where immutability
and referential transparency are favored, but not required.
\item The native macro system allows definition of new syntax (and even entire
domain-specific languages) using regular Fn code and data structures.
\end{itemize}

The syntax looks like this:

\begin{verbatim}
(def sqrt-precision 0.001)
(def approx-sqrt (x)
  (letfn iterate (guess)
    (if (< (abs (- x (* guess guess)) sqrt-precision))
        guess
        (iterate (/ (+ guess (/ x guess) 2)))))
  (if (>= x 0)
      (iterate (/ x 2))
      (error "Cannot approximate square root of a negative number.")))
\end{verbatim}


\subsection{Variables and Mutation}
\label{sec:org761ce8a}

\subsubsection{Local Variables}
\label{sec:org45e7d44}

Local variables can be created using one of the special operators \texttt{let}, \texttt{letfn}, or
\texttt{with}.\footnote{In Fn, the \texttt{with} operator provides the functionality of what
most Lisp-like languages call \texttt{let}, while Fn's \texttt{let} is quite different, as it acts
on the surrounding environment.} They all bind variables in the same way, but with
different syntax for programmer convenience. Function parameters are also
treated as local variables within the function body.

Before proceeding, we note that the full story about local variables involves
variable capture semantics, which are covered in a later section. Variable
capture doesn't affect any of the concepts discussed in the rest of this section.

\texttt{let} is the most elementary way to create a local variable. It defines one or
more new variables in the current lexical environment.

\begin{verbatim}
;; let binds variables to the given values
(let x 'symbol)
;; multiple definitions can be made in a single let
(let a 16
     b (reverse "string")
     ;; value expressions can refer to variables from earlier in the same let
     c (+ a (length b))
\end{verbatim}

\texttt{with} is similar to \texttt{let}, but rather than creating definitions in the containing
environment, it creates a new lexical environment.

\begin{verbatim}
;; this creates two variables
(with (a 3
       b 4)
  ;; the body can contain multiple expressions
  (println "hello")
  (+ a b))
;; returns 7
;; the variables a, b do not exist outside of the with body
\end{verbatim}

\texttt{letfn} has a streamlined syntax for creating functions, but otherwise behaves
like \texttt{let}. See the documentation below for details.

All local variables can have their value changed with \texttt{set!}. The exclamation
point is because mutation is not to be taken lightly. The syntax for \texttt{set!} is
like this:

\begin{verbatim}
(set! var-name new-value)
;; for example
(let var 'hi)
(println var) ;; prints 'hi
(set! var 'lo)
(println var) ;; prints 'lo
\end{verbatim}

Note that attempting to \texttt{set!} a global variable will result in an error.


\subsubsection{Global Variables}
\label{sec:org51a388d}

Global variables in Fn are created using \texttt{def} or \texttt{defn}. E.g.

\begin{verbatim}
(def my-global 'special-constant)
(def my-other-global (+ 21 69))
\end{verbatim}

\texttt{defn} behaves exactly like \texttt{def}, but has special syntax streamlined for defining
functions.

Global variables are immutable, i.e. they cannot be changed by using \texttt{set!}.
However, by assigning global variables to mutable datatypes or by exploiting
variable capture (discussed in a later section), mutable state can still be
associated to a global variable. This is intended behavior, however, it is not
recommended that you abuse it.


\subsection{Data Types}
\label{sec:org6918fb9}

Fn provides the following builtin data types (type names in Fn are
\texttt{Capitalized-Like-This}):

\begin{description}
\item[{\texttt{Nil}}] The special constant \texttt{nil}, used to indicate no value.
\item[{\texttt{Bool}}] The special boolean constants \texttt{true} and \texttt{false}.
\item[{\texttt{Num}}] Floating-point numbers. (These are almost IEEE 64-bit floats, but we
truncate the significand by four bits to fit type information).
\item[{\texttt{Symbol}}] Internalized strings. These are essentially strings with a faster
equality test, at the expensive of slower access to the characters of the
string. They are used extensively by the macro system.
\item[{\texttt{String}}] (Immutable) sequences of bytes. Usually these are UTF-8 encoded
character streams.
\item[{\texttt{List}}] (Immutable) singley-linked lists.
\item[{\texttt{Table}}] Mutable key-value stores.
\end{description}

Of these, only lists and tables logically contain other values. (Substrings can
be extracted from strings, but this actually creates a new string object and
just copies in data from the other string). So, we call \texttt{List} and \texttt{Table} the two
\textbf{compound data types}, and call the rest of them \textbf{simple data types}.

\subsubsection{Simple Data Types}
\label{sec:orgd68ab38}
Here is what the syntax looks like for the simple data types:

\begin{verbatim}
;; numbers are pretty much what you'd expect
2
-6
3.14159
2.0e-6 ;; we have scientific notation
0xFf ;; hexadecimal, even!

;; strings are enclosed within matched double quotes
"string"
"Fn uses escape codes from C, e.g. \\ \"\n"
""

;; symbols are prefixed by a single quote.
'sym1
'sym2
;; symbols can contain whitespace and syntax characters, provided they are 
;; escaped with a backslash
'sym\ with\ \"escapes\"
;; be careful about the quote operator. If the quoted expression is a number,
;; it will result in a number instead of a symbol. You can get around this 
;; with escapes:
'0xb8  ;; this is a number
'\0xb8 ;; this is a symbol

;; booleans and nil are called by name
true
false
nil
\end{verbatim}

See also subsection \ref{sec:orgef30853} for more on symbols and the quote operator.


\subsubsection{Lists}
\label{sec:org73f773f}

Lists in Fn are what you'd expect for a functional programming language. They're
created using square brackets or by using the \texttt{List} function.

\begin{verbatim}
[] ; empty list
['a 'b] ; list of two symbols
[1 'a "str"] ; lists may contain objects of arbitrary type

;; List is identical to square bracket syntax
[1 2 3]
(List 1 2 3)
\end{verbatim}

Lists can be manipulated with builtin functions:

\begin{verbatim}
(def list1 [["str" 2] 'a 'b])
(def list2 [0 2 4 6 8 10])

;; head and tail access the head and tail of the list
(head list1) ;=> ["str" 2]
(head list2) ;=> 0
(tail list1) ;=> ['a 'b]

(tail [])    ;=> []
(head [])    ;=> error (empty list has no head)

;; nth allows random access:
(nth list1 2) ;=> 'b
(nth list2 1) ;=> 2

;; length gives the length of a list
(length []) ;=> 0
(length list1) ;=> 3
(length list2) ;=> 6

;; cons prepends elements
(cons 2 []) ;=> [2]
(cons nil list1) ;=> [nil ["str" 2] 'a 'b]

;; concat concatenates two or more lists
(concat [1 2 3] [4 5 6]) ;=> [1 2 3 4 5 6]
(concat [37] ['foo] ["bar"]) ;=> [37 'foo "bar"]
(concat list2 list1) ;=> [0 2 4 6 8 10 ["str" 2] 'a 'b]

;; reverse reverse the direction of a list
(reverse list2) => [10 8 6 4 2 0]
\end{verbatim}


\subsubsection{Tables}
\label{sec:org85de6b3}

Tables are key-value stores. Any type of object may be used as a key or a value,
(note, however, that it takes longer to hash more complicated data structures
since we have to descend on their fields)\footnote{Two keys are equal if \texttt{(= k1 k2)} is true (using the builtin
equality function). For simple data types the meaning of equality is obvious.
Lists and tables are compared componentwise. That is, two lists are equal if and
only if all their respective entries are equal. Two tables are equal if their
key sets are equal (disregarding order), and for each key the corresponding
values in each table are equal.}.

Tables are built using braces \texttt{\{\}} or the equivalent \texttt{Table} function. This must be
passed an even number of arguments.

\begin{verbatim}
{} ;=> empty table
{'key1 4 'key 6} ;=> table with two kv-pairs
(Table 'key1 4 'key 6) ;=> table with two kv-pairs
\end{verbatim}

Table elements may be accessed using the builtin function \texttt{get}. When the key is a
constant symbol, dot syntax (or the equivalent \texttt{dot} special operator) can be
used instead. This is how this looks:

\begin{verbatim}
(def tab1 {'name "Mr. Table"
          'occupation "Holds data"
          'child {'name "Table Jr." 
                  'occupation "Holds less data"}})
(def tab2 {0 'zero 1 'one 2 'two 3 'three 4 'four})

;; these all return "Mr. Table"
(get tab1 'name)
tab1.name
(dot tab1 name) ; equivalent syntax to the dot expression
;; Note that the symbols in the dot expressions are unquoted. Arguments to dot 
;; must be unquoted symbols or a compilation error occurs.

;; get is more flexible than dot and allows arbitrary key and value expressions
(get tab2 (+ 1 2)) ;=> 'three
(get {'k 'v} 'k) ;=> 'v

;; dot makes it convenient to descend on tables with symbolic key names
tab1.child.name ;=> "Table Jr."
;; equivalent expression:
(dot tab1 child name)
\end{verbatim}

Since tables are mutable, the main way to populate them is to use the \texttt{set!}
operator (the same one as for local variables). In this case, the first argument
may be any legal \texttt{get} or \texttt{dot} expression on a table.

Lastly, tables size can be checked with \texttt{length}, a list of keys can be retrieved
with \texttt{table-keys}, and two or more tables can be combined with \texttt{concat} (if any of
the tables have keys in common, the last table in the argument list takes
priority).


\subsubsection{Quoting}
\label{sec:orgef30853}

"Quoting" refers to the process of converting Fn source code into native Fn
data. This allows us to easily process and manipulate Fn source code using the
same facilities as for normal data.

Quoting is the secret sauce that makes Fn's macro system work. It's the main
reason why Fn has the syntax it has.

The \texttt{quote} special operator has syntax:
\begin{verbatim}
(quote <expr>) ;; or, equivalently
'<expr>
\end{verbatim}
where \texttt{<expr>} can be any expression (in fact, it need not be a legal expression
by itself). These two notations are exactly the same. The interpreter expands
the second into the first before evaluation.

The value returned by quote is guaranteed to only consist of lists, symbols,
numbers, and strings. We refer to the latter three as \textbf{atoms}. Here are some
examples:
\begin{verbatim}
'(a b c) ;; returns ['a 'b 'c]
'"string" ;; returns "string"
'(+ a (/ x 2)) ;; returns ['+ 'a ['/ 'x 2]]

''quot ;; is equivalent to
(quote (quote quot)) ;; which returns ['quote 'quot]
\end{verbatim}

Note that \texttt{<expr>} only needs to be syntactically valid (i.e. not freak out the
parser). Illegal expressions can be quoted just fine:
\begin{verbatim}
'() ;; returns [] (the empty list)
'(2 (3 4)) ;; returns [2 [3 4]]
'(quote) ;; returns ['quote]
\end{verbatim}

This makes \texttt{quote} very handy for creating nested lists of atoms. (\texttt{quote} also has
a big sister named \texttt{quasiquote}, which is covered in the section on macros, and
allows for much more flexibility).

\texttt{quote} is also the primary way to create symbols. As noted in subsection \ref{sec:orgd68ab38}, this can lead to problems when we want a symbol whose name is a
syntactically valid number. Adding an escape character to the symbol name
designates to the parser that the token should be read as a symbol rather than a
number. In fact, we can even use this trick to give variables numbers for names:
\begin{verbatim}
;; probably don't do this
(def \2 3)
2  ;; returns 2
\2 ;; returns 3
\end{verbatim}

My recommendation: just don't use symbol names that are syntactically legal
numbers.


\subsection{{\bfseries\sffamily TODO} Control Flow and Functions}
\label{sec:org679c46d}

\subsubsection{Conditional Execution}
\label{sec:orgb1b9cca}

The conditional control flow primitives are \texttt{if} and \texttt{cond}.

\texttt{if} takes exactly three arguments: a test expression, an expression to evaluate
if the test is true, and an expression to evaluate if the test is false. In Fn,
\texttt{nil} and \texttt{false} are considered to be false values, while all others are treated as
\texttt{true}.
\begin{verbatim}
;; if and cond syntax

;; cond takes pairs of expressions and consequences
(cond
  false 1
  nil   2
  'foo  3
  true  4)
; => returns 3, because 'foo is the first true value

(defn fizzbuzz (x)
  (cond
    (= (mod x 15) 0) 'FizzBuzz
    (= (mod x 5) 0)  'Buzz
    (= (mod x 3) 0)  'Fizz
    true             x))
(fizzbuzz 6)  ; = Fizz
(fizzbuzz 7)  ; = 7
(fizzbuzz 45) ; = FizzBuzz
(fizzbuzz 65) ; = Buzz
\end{verbatim}

\texttt{cond} is an alternative conditional syntax which is analogous to "if/else if"
blocks in other programming languages. \texttt{cond} takes pairs of arguments and treats
the first one as a test. If the test is true, it returns the result of the
second argument in the pair. Otherwise it proceeds to the next pair, returning
\texttt{nil} if the end is reached.


\subsubsection{Creating Functions}
\label{sec:orgd6347d1}

Functions are created using \texttt{fn}.

A short syntax is also provided for creating functions via the dollar sign,
which expands into a \texttt{dollar-fn} special form.

For example:
\begin{verbatim}
(fn (x) (* x x))
$(* $ $)
(dollar-fn (* $ $))
\end{verbatim}

All three of the above take in a single argument and square it. Note that
dollar-fn uses \texttt{\$} (or equivalently, \texttt{\$0}) for the name of the first parameter.
(Other positional parameters can be accessed with \texttt{\$1}, \texttt{\$2}, and so on). See
subsection \ref{sec:org8e5416c} for more details.

\texttt{fn} on the other hand has an explicit parameter list. The syntax for parameter
lists is this:
\begin{verbatim}
param-list      ::=  '(' <req-param>* <opt-param>* <var-params>? ')'
req-param       ::= <identifier>
opt-param       ::= (<identifier> <init-form>)
var-params      ::= <var-list-param> <var-table-param>?
                  | <var-table-param> <var-list-param>?
var-list-param  ::= '&' <identifier>
var-table-param ::= ':&' <identifier>
\end{verbatim}

In other words, parameter lists consist of zero or more required parameters,
zero or more optional parameters, and optionally end with variadic table and
list arguments.

Each of these parameters has an associated identifier (i.e. a symbol that is a
legal name). In the function's body, the respective arguments are bound to these
names. See subsection \ref{sec:orgc5c7f45} for information about how argument lists
are processed during function calls.


\subsubsection{Function Calls}
\label{sec:orgc5c7f45}

Fn allows arguments to be named in function calls very similarly to Python.
Named arguments are passed using keywords, which are simply symbols whose names
begin with \texttt{:}. These symbols are not legal identifiers, so their appearance in
function calls is unambiguous. We also place the restriction that positional
arguments may not follow named ones. (Believe me, I tried to make it work
without that, and it's a mess at every level).

First we will deal with the case where there are no variadic parameters. See the
following example.
\begin{verbatim}
;; this function has 3 positional parameters, the last of which is optional
(defn arg-demo (x y (z 2))
  (* z (+ x y)))

;; here are a couple of ways we could call this function
(arg-demo 2 3)            ; x = 2, y = 3, z = 2, result = 10
(arg-demo 2 3 4)          ; x = 2, y = 3, z = 4, result = 20
(arg-demo :x 2 :y 3)      ; x = 2, y = 3, z = 2, result = 10
(arg-demo :z 2 :y 3 :x 2) ; x = 2, y = 3, z = 2, result = 10
(arg-demo :z 3 1 2)       ; error! positional argument following named argument
\end{verbatim}

To be precise, function parameters (still considering the case where there are
no variadic parameters) are bound using the following procedure:
\begin{itemize}
\item the unnamed arguments are bound to positional parameters in order
\item the named arguments are bound to their respective parameters, raising an error
if any duplicates or unrecognized names are found
\item unbound optional parameters are set to their default values. If any required
parameters remain unbound, an error is raised
\end{itemize}

Now, variadic arguments change some of the rules. We have two types of variadic
parameters in Fn: variadic tables, and variadic lists.

For tables, the semantics are very simple. Functions with a variadic table
parameter can accept any named argument, not just the names corresponding to
their functions (duplicated names are still not allowed). Moreover, it's now
possible for a named argument to have the same name as a positional argument.
\begin{verbatim}
;; demo function ignores first arg and returns table
(def var-tab-demo ((x nil) :& tab) ; variadic table arguments denoted with :&
  tab)

(var-tab-demo 0)         ; result = {}
(var-tab-demo :y 2 :x 1) ; result = {'y 1}
(var-tab-demo 1 :x 2)    ; result = {'x 2}
\end{verbatim}

As can be seen above, the variadic table is constructed by taking all
unrecognized named arguments and inserting them into the table as key-value
pairs. Moreover, if a named argument is recognized, but was already provided as
a positional argument, then that goes to the variadic table as well.

Variadic lists are analogous to variadic tables, but where those act on trailing
named arguments, variadic lists act on trailing positional arguments. As such,
it is impossible to use named arguments while at the same time passing a
non-empty variadic list argument, except in the case where there is also a
variadic table parameter to catch the trailing arguments.
\begin{verbatim}
;; demo function ignores first arg and returns list
(def var-lst-demo (x & list) ; variadic lists denoted with &
  list)

(var-lst-demo 0 1 2)  ;=> [1 2]
(var-lst-demo 0)      ;=> []
(var-lst-demo 0 :x 2) ;=> syntax error
(var-lst-demo :x 0)   ;=> []
(var-lst-demo :x 0 1) ;=> syntax error

;; demo function using both variadic parameters
(def var-mixed-demo (x & list :& table)
  [list table])

;; names not explicitly in the parameter list get sent to the variadic table
(var-mixed-demo :x 4 :y 2) ;=> [[] {'y 2}]
;; with a variadic table argument, duplicate names are allowed if one is a 
;; positional arg:
(var-mixed-demo 'a 'b :x 4 :y 2) ;=> [['b] {'x 4 'y 2}]
;; as always, keywords cannot precede positional arguments
(var-mixed-demo :x 4 :y 2 'a 'b) ;=> syntax error
\end{verbatim}


\subsubsection{{\bfseries\sffamily TODO} Variable Capture}
\label{sec:org5f73b62}


\subsubsection{{\bfseries\sffamily TODO} dollar-fn}
\label{sec:org8e5416c}


\subsection{{\bfseries\sffamily TODO} Namespaces and Import}
\label{sec:org3eb67b4}

\subsubsection{Namespaces and Packages}
\label{sec:org8fdf53d}

A namespace is a collection of global variables and macros. They are identified
by a name which is required to be globally unique. All Fn code lives inside of
some namespace.

Some examples of namespace names are:
\begin{verbatim}
fn/builtin
fn/repl
project/main
project/subsystem/parser
\end{verbatim}

The slashes above are delimiters. In particular, everything to the left of the
last slash is called the \textbf{package name}, and the part to the right is called the
\textbf{short name}. For instance the namespace \texttt{project/subsystem/parser} has package
\texttt{project/subsystem} and short name \texttt{parser}.

We also have the concept of a \textbf{subpackage}. In the above examples,
\texttt{project/subsystem} is a subpackage of \texttt{project}. That is, the subpackages of a
\texttt{<pkg>} are all packages with names of the form \texttt{<pkg>/...}.


\subsubsection{Namespace Determination}
\label{sec:orgf0cd9c9}

When a file is interpreted, the short name of the namespace is set to the stem
of the filename. There is no way to change this. The package, however, may be
anything at all, and is specified by putting a \texttt{package} declaration at the top of
the file:

\begin{verbatim}
(package myproject/util)
\end{verbatim}

If no package declaration is present, the package \texttt{fn/user} is used by default.

Unlike other special forms in Fn, there can only be one package declaration per
file, and it must come at the beginning of the file, although it can be
preceeded by comments and whitespace.

The REPL allows the current namespace to be changed interactively. By default it
uses the namespace \texttt{fn/repl}.


\subsubsection{Importing Namespaces}
\label{sec:org532b7e4}

Importing a namespace means taking its bindings into the current namespace.


\subsubsection{Builtin Namespace}
\label{sec:org3370284}

When a new namespace is created, an unqualified import of \texttt{fn/builtin} is
automatically performed.


\subsubsection{Global Names}
\label{sec:orgb090073}

After a namespace has been imported once, its bindings can be referenced even
without importing it explicitly. This is done by using symbols whose names are
structured like with \texttt{/<namespace>:<symbol>}. For example, \texttt{/fn/builtin:map}
refers to the function \texttt{map} in the \texttt{fn/builtin} namespace.


\subsection{{\bfseries\sffamily TODO} Macros}
\label{sec:orgbcf79c6}

\subsubsection{Macro Basics}
\label{sec:org20cc8cc}

\subsubsection{Quasiquotation}
\label{sec:orgf5b9097}

\subsubsection{Variable Capture and \texttt{gensym}}
\label{sec:org76c455d}
\end{document}