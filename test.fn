(namespace fn.example/lazy)

(def Lazy-List
     (set-metatable
      {'__call
       ; constructor
       (fn (self value-fun)
         (let res {})
         (set! (. res 'force)
               (fn ()
                 ; evaluate the value function
                 (let v (value-fun))
                 ; replace the force method
                 (set! (. res 'force) (fn () v))
                 v))
         (set-metatable Lazy-List res))}
      {'head (fn (self)
               (head ((. self 'force))))
       'tail (fn (self)
               (head (tail ((. self 'force)))))
       'empty? (fn (self)
                 (= ((. self 'force)) nil))}))

(defn list->lazy (list)
  (if (empty? list)
      (Lazy-List (fn () nil))
      (Lazy-List (fn () [(head list)
                         (list->lazy (tail list))]))))

(defn reverse (list)
  (letfn iter (acc l)
    (if (empty? l)
        acc
        (iter (cons (head l) acc) (tail l))))
  (iter [] list))

(defn lazy->list (lazy)
  (letfn iter (acc rem)
    (if (empty? rem)
        (reverse acc)
        (iter (cons (head rem) acc)
              (tail rem))))
  (iter [] lazy))

(defn lcons (hd lazy)
  (Lazy-List (fn ()
               [hd lazy])))

(defn lconcat (l1 l2)
  (if (empty? l1)
      l2
      (Lazy-List
       (fn () [(head l1)
               (lconcat (tail l1) l2)]))))

(defn ltake (n lazy)
  (letfn iter (acc m rem)
    (if (or (empty? rem) (<= m 0))
        (reverse acc)
        (iter (cons (head rem) acc)
              (- m 1)
              (tail rem))))
  (iter [] n lazy))


(defn lmap (fun lazy)
  (if (empty? lazy)
      (list->lazy [])
    (Lazy-List
     $[(fun (head lazy))
       (lmap fun (tail lazy))])))

(defn unbox-lazy (lazy)
  [(head lazy) (tail lazy)])

(defn lfilter (pred lazy)
  (letfn next (rem)
         (cond
           (empty? rem) rem
           (pred (head rem))
           (lcons (head rem)
                  (Lazy-List (fn () (unbox-lazy (next (tail rem))))))
           yes (next (tail rem))))
  (next lazy))

(def N>=0
  (do 
    (let next-int
         (fn (x) (Lazy-List
                  (fn () [x (next-int (+ x 1))]))))
    (next-int 0)))

; (list->lazy [1 2 3 4])

(do
  (let init-primes (list->lazy [2 3 5 7])
       next-pair
       (fn (x)
         (Lazy-List
          (fn () [(- (* 6 x) 1)
                  (lcons (+ (* 6 x) 1)
                         (next-pair (+ x 1)))])))
       candidates (next-pair 2))
  (letfn prime-test? (x)
    (let max (ceil (** x 0.5)))
    (letfn iter (rem)
      (let n (head rem))
      (cond
        (= (mod x n) 0) no
        (>= n max) yes
        yes (iter (tail rem))))
    (iter primes))
  (def primes
    (lconcat init-primes
             (Lazy-List (fn ()
                          (let next (lfilter prime-test? candidates))
                          [(head next) (tail next)])))))

(defn lnth (n l)
  (if (<= n 0)
      (head l)
      (lnth (- n 1) (tail l))))

; (lnth 9 primes)
(lnth 99999 primes)
; (lnth 5 N>=0)
