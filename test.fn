(def Lazy-List-Meta
  {'force (fn (self)
            ((. self 'force) self))
   'empty? (fn (self)
             (= ((. self 'force) self) nil))
   'head (fn (self)
           (head ((. self 'force) self)))
   'tail (fn (self)
           (head (tail ((. self 'force) self))))
   'map (fn (self fun)
          (lmap fun self))
   'filter (fn (self fun)
             (lfilter fun self))})

; (defn List (& args)
;   args)

; (with (old-head head
;        old-tail tail)
;   (defn head (x)
;     (if (list? x)
;         (old-head x)
;         (.head x)))
;   (defn tail (x)
;     (if (list? x)
;         (old-tail x)
;         ('tail x))))

(defn Lazy-List (fun)
  (with-metatable Lazy-List-Meta
    {'force (fn (self)
              (let val (fun))
              (set! (. self 'force)
                    (fn (self) val))
              val)}))

(defn list->lazy (list)
  (if (empty? list)
      (Lazy-List (fn () nil))
      (Lazy-List $[(head list)
                   (list->lazy (tail list))])))

(defn reverse (list)
  (letfn iter (acc l)
    (if (empty? l)
        acc
        (iter (cons (head l) acc) (tail l))))
  (iter [] list))

(defn lazy->list (lazy)
  (letfn iter (acc rem)
    (if (.empty? rem)
        (reverse acc)
        (iter (cons (.head rem) acc)
              (.tail rem))))
  (iter [] lazy))

(defn lcons (hd lazy)
  (Lazy-List (fn ()
               [hd lazy])))

(defn lconcat (l1 l2)
  (if (.empty? l1)
      l2
      (Lazy-List
       $[(.head l1)
         (lconcat (.tail l1) l2)])))

(defn ltake (n lazy)
  (letfn iter (acc m rem)
    (if (or (.empty? rem) (<= m 0))
        (reverse acc)
        (iter (cons (.head rem) acc)
              (- m 1)
              (.tail rem))))
  (iter [] n lazy))


(defn lmap (fun lazy)
  (if (.empty? lazy)
      (list->lazy [])
    (Lazy-List
     $[(fun (.head lazy))
       (lmap fun (.tail lazy))])))

(defn unbox-lazy (lazy)
  [(.head lazy) (.tail lazy)])

(defn lfilter (pred lazy)
  (letfn next (rem)
         (cond
           (.empty? rem) rem
           (pred (.head rem))
           (lcons (.head rem)
                  (Lazy-List $(unbox-lazy (next (.tail rem)))))
           yes (next (.tail rem))))
  (next lazy))

(def N>=0
  (with (next-int
         $(Lazy-List (fn ()
                       [$0 (next-int (+ $0 1))])))
    (next-int 0)))

; (list->lazy [1 2 3 4])

(do
  (let init-primes (list->lazy [2 3 5 7])
       candidates
       (with (next-pair
              (fn (x)
                (Lazy-List
                 $[(- (* 6 x) 1)
                   (lcons (+ (* 6 x) 1)
                          (next-pair (+ x 1)))])))
         (next-pair 2)))
  (letfn prime-test? (x)
    (let max (ceil (** x 0.5)))
    (letfn iter (rem)
      (let n (.head rem))
      (cond
        (= (mod x n) 0) no
        (>= n max) yes
        yes (iter (.tail rem))))
    (iter primes))
  (def primes
    (lconcat init-primes
             (Lazy-List (fn ()
                          (let next (.filter candidates prime-test?))
                          [(.head next) (.tail next)])))))

(defn lnth (n l)
  (if (<= n 0)
      (.head l)
      (lnth (- n 1) (.tail l))))

(lnth 99999 primes)
