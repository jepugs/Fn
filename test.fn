(namespace fn.example/lazy)

(def Lazy-List
     (set-metatable
      {'__call
       ; constructor
       (fn (self value-fun)
         (let res {})
         (set! (. res 'force)
               (fn ()
                 ; evaluate the value function
                 (let v (value-fun))
                 ; replace the force method
                 (set! (. res 'force) (fn () v))
                 v))
         (set-metatable Lazy-List res))}
      {}))

; (defn Lazy-List (value-fun)
;   (let res {})
;   (set! (. res 'force)
;         (fn ()
;           ; evaluate the value function
;           (let v (value-fun))
;           ; replace the force method
;           (set! (. res 'force) (fn () v))
;           v))
;   res)

(defn lempty? (l)
  (= ((. l 'force)) nil))

(defn lhead (l)
  (head ((. l 'force))))
; (defn ('head Lazy-List) (self)
;   (lhead self))

(defn ltail (l)
  (nth 1 ((. l 'force))))
; (defn ('tail Lazy-List) (self)
;   (ltail self))

; (defn ('map Lazy-List) (self fun)
;   (if (lempty? lazy)
;       (list->lazy [])
;       (Lazy-List
;        (fn () [(fun (lhead lazy))
;                (lmap fun (ltail lazy))]))))

; (defn ('filter Lazy-List) (self fun)
;   (lfilter fun self))

(defn list->lazy (list)
  (if (empty? list)
      (Lazy-List (fn () nil))
      (Lazy-List (fn () [(head list)
                         (list->lazy (tail list))]))))

(defn reverse (list)
  (letfn iter (acc l)
    (if (empty? l)
        acc
        (iter (cons (head l) acc) (tail l))))
  (iter [] list))

(defn lazy->list (lazy)
  (letfn iter (acc rem)
    (if (lempty? rem)
        (reverse acc)
        (iter (cons (lhead rem) acc)
              (ltail rem))))
  (iter [] lazy))

(defn lcons (hd lazy)
  (Lazy-List (fn ()
               [hd lazy])))

(defn lconcat (l1 l2)
  (if (lempty? l1)
      l2
      (Lazy-List
       (fn () [(lhead l1)
               (lconcat (ltail l1) l2)]))))

(defn ltake (n lazy)
  (letfn iter (acc m rem)
    (if (or (lempty? rem) (<= m 0))
        (reverse acc)
        (iter (cons (lhead rem) acc)
              (- m 1)
              (ltail rem))))
  (iter [] n lazy))


(defn lmap (fun lazy)
  (if (lempty? lazy)
      (list->lazy [])
    (Lazy-List
     $[(fun (lhead lazy))
       (lmap fun (ltail lazy))])))

(defn unbox-lazy (lazy)
  [(lhead lazy) (ltail lazy)])

(defn lfilter (pred lazy)
  (letfn next (rem)
         (cond
           (lempty? rem) rem
           (pred (lhead rem))
           (lcons (lhead rem)
                  (Lazy-List (fn () (unbox-lazy (next (ltail rem))))))
           yes (next (ltail rem))))
  (next lazy))

(def N>=0
  (do 
    (let next-int
         (fn (x) (Lazy-List
                  (fn () [x (next-int (+ x 1))]))))
    (next-int 0)))

; (list->lazy [1 2 3 4])

(do
  (let init-primes (list->lazy [2 3 5 7])
       next-pair
       (fn (x)
         (Lazy-List
          (fn () [(- (* 6 x) 1)
                  (lcons (+ (* 6 x) 1)
                         (next-pair (+ x 1)))])))
       candidates (next-pair 2))
  (letfn prime-test? (x)
    (let max (ceil (** x 0.5)))
    (letfn iter (rem)
      (let n (lhead rem))
      (cond
        (= (mod x n) 0) no
        (>= n max) yes
        yes (iter (ltail rem))))
    (iter primes))
  (def primes
    (lconcat init-primes
             (Lazy-List (fn ()
                          (let next (lfilter prime-test? candidates))
                          [(lhead next) (ltail next)])))))

(defn lnth (n l)
  (if (<= n 0)
      (lhead l)
      (lnth (- n 1) (ltail l))))

; (lnth 9 primes)
(lnth 99999 primes)
; (lnth 5 N>=0)
