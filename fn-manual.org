#+TITLE: Fn Programming Language Manual 0.1 (WIP)
#+AUTHOR: Jack Pugmire
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="style.css"/>
#+HTML_HEAD_EXTRA: <link rel="stylesheet-alternate" type="text/css" href="style.css"/>

* Introduction

This is the official manual for Fn. It is /almost entirely/ accurate to the
current implementation of Fn in this repository. A list of disparities and
missing functionality is in the file [[./implementation-progress.org]]. At the time
of writing, the base language is fully implemented barring some details about
namespace imports, but not all the functionality is documented here yet.

Sections marked *TODO* are works in progress. I'm rewriting a lot of this to make
it more readable, since the first pass was overly dense and technical.

The structure of this manual is as follows:

- [[Language Guide]] contains a walkthrough of all the major features of the Fn
  language. An experienced programmer should be able to skim over this section
  and get enough of an idea to start using Fn.

- [[Command Line Interface]] gives instructions on using the ~fn~ command line
  tool to run code.

- [[Builtin Functions]] contains a list of functions included in the ~fn/builtin~
  namespace.

- [[FFI]] details how to interface with C code from Fn.

Fn is a dynamically typed, garbage-collected, general-purpose programming
language with Lisp-derived syntax.
- The core language has relatively few operations, with special care taken to
  ensure they have consistent and concise syntax.
- Fn is designed for a "mostly functional" programming style, where immutability
  and referential transparency are favored, but not required.
- The native macro system allows definition of new syntax (and even entire
  domain-specific languages) using regular Fn code and data structures.


** Notes for Those Familiar with Lisp

This little section is only for people who are already fluent in another dialect
of Lisp such as Common Lisp, Clojure, or Scheme. Other readers should skip it
(unless you're curious).

Fn is a Lisp, so if you have experience with other languages in the
family, you should find Fn to be quite comfortable. That said, you must tread
with caution. I changed a lot with no regard for history.

Fn is a case-sensitive Lisp-1 with unhygienic macros. Name collision problems
are solved by organizing code into namespaces, and giving every global
definition a unique *global identifier*. E.g., a macroexpansion using the builtin
~map~ function should refer to it by its global identifier ~#/fn/builtin:map~.
Language facilities are provided to make this more convenient.

Here are a couple of the ways I've broken with traditional Lisp:

1. ~car~, ~cdr~ and the rest are completely absent, replaced by ~head~, ~tail~, and ~nth~.
   I acknowledge that ~cadadr~ and company are good for tree traversal, but the
   names are sooooo bad. I hope to capture this lost functionality with a
   pattern matching solution.
2. Dotted pairs are also gone. The tail of every ~cons~ cell is required to be a
   list. The dot operator has been repurposed as an accessor.
3. Fn's ~cond~ has the syntax of Clojure's ~cond~, rather than that from CL or
   Scheme. That is, we've dropped the inner parentheses, so you'd say ~(cond test
   expr)~ instead of ~(cond (test expr))~. As a consequence, multiple-expression
   clauses must be wrapped in a ~do~ block.
4. ~do~ is not a looping construct, but rather the Fn analogue for ~progn~ or ~begin~.
   This is also something which was done in Clojure.
5. The most egregious change I've made is to ~let~. ~let~ expressions no longer
   contain a body. Instead, they occur within ~do~ blocks or function bodies and
   introduce new variables without increasing the level of indentation.
6. Fn provides a special form called ~with~ which has syntax and semantics like
   ~letrec~, although the inner parentheses in the binding form have been dropped.

With respect to points 5 and 6 above, this is how ~let~ and ~with~ work:
#+BEGIN_SRC fn
(do
  (let x 6)
  (+ x 7))   ; => 13

(with (x 7
       y 8)
  (* x y))    ; => 56
#+END_SRC


* Language Guide

** Basic Syntax

This section introduces some elementary aspects of Fn's syntax so that they can
be used in the examples throughout the rest of the guide. It should also give
you an idea of the general flavor of Fn.

To get started, let's take a look at Fn's syntax. Fn uses *parenthesized
prefix notation*, meaning expressions are between parentheses and the operation
comes first (it's a prefix to its arguments). This is what it looks like:

#+BEGIN_SRC fn
; note: comments begin with semicolons

; the basic syntax is (<operator> <arguments> ...)

; this syntax used for defining variables
(def x 42) ; => defines a global variable named x

; parenthesized prefix notation is also used for function calls
(length [1 2 3])  ; => 3, i.e. the length of the list [1 2 3]

; this is how you do arithmetic in Fn
(+ 6 7)  ; => 13
(- 2 3)  ; => -1
(* 6 8)  ; => 48
(/ 7 7)  ; => 1

; function calls can be nested
(- (/ 6 2) 3)        ; => 0
(* (+ 2 3) (+ 5 5))  ; => 50

; arithmetic functions accept varying numbers of arguments:
(+ 1 2 3 4)  ; => 10
(/ 6 3 2)    ; => 1  read as (6 / 3) / 2 in infix notation

; some functions have side effects like performing I/O
(println "Hello, World!")   ; need I say what this does?

; functions are created with the fn operator
(fn (x) (* x 2))   ; => 1-argument function that multiplies an
                   ;    argument by 2
(fn (x y) (/ y x)) ; => 2-argument function that divides y by x

; defn is a portmanteau of def and fn for defining functions
(defn times2 (x)
  (* x 2))
#+END_SRC

Fn also has some syntactic sugar to make certain common operations more
convenient. For example, the ~quote~ operation (used to construct certain objects)
can be written like this:
#+BEGIN_SRC fn
'quoted-form
#+END_SRC
This is expanded into the following before compilation:
#+BEGIN_SRC fn
(quote quoted-form)
#+END_SRC
This means that all Fn code can be expanded to be written in prefix notation. As
a consequence, it's quite easy to represent Fn source code as a tree. This idea
is explored in more detail in [[Quoting and Macros]]. (As an additional note, the
code in the example above simply creates a symbol object named "quoted-form".
For the basics of symbols, see [[Working with Atoms]]).

One more thing that makes Fn (and the Lisp family in general) a little different
is that variable names may contain some punctuation characters such as ~?~ and ~-~
which are prohibited in many languages. There's no sense going into the fine
details here, but don't be confused when you see names including these
characters, as they don't have any special meaning.


** Overview of Data Model

In Fn, an *object* or *value* is the result of an expression. Fn has no distinction
between expressions and statements. Every form is an expression that returns a
value. Expressions with no logical return value should return the special
constant ~nil~.

Fn's data types can be divided into *atomic* and *non-atomic* types. (Instances of
atomic types are called *atoms*). Atomic types are defined by the fact that they
do not reference any other objects. Atoms in Fn consist of *strings*,
(floating-point) *numbers*, *symbols* (which are internalized strings), *booleans*,
and the *nil* value.

Non-atomic values in Fn consist of *lists*, *tables*, and *functions*.

*** Working with Atoms

**** Numbers

Numbers are pretty much what you'd expect. We use the same syntax as in C/C++,
(excluding octal numbers). Here are a few examples:
#+BEGIN_SRC fn
2
-6
2.0e-6   ; we have scientific notation
0xFf     ; hexadecimal, even!
#+END_SRC

Here are a few elementary functions for working with numbers:
#+begin_src fn
; We've already met the arithmetic functions +, -, *, and /
(* (+ 2 2) (- 12 10) (/ 16 4))  ; => 32
; These can be called with arbitrarily many arguments
(+ 1 2 3 4) ; => 10 (read as 1 + 2 + 3 + 4)
(/ 8 2 2 2) ; => 1  (read as 8 / 2 / 2 / 2)

; - and / have special behavior when called with a single argument
(- 6) ; => -6 (i.e. additive inverse)
(/ 2) ; => 0.5 (i.e. multiplicative inverse)

; ** is the exponentiation function
(** 4 2)   ; => 16
(** 4 0.5) ; => 2

; mod computes modulus by an integer.
(mod 27 4)  ; => 3
(mod 8 2)   ; => 0
; first argument need not be an integer
(mod 6.5 2) ; => 0.5

; floor and ceil are the floor and ceiling functions
(floor 0.8) ; => 0
(ceil 0.8)  ; => 1

; integer? returns true for integers, false otherwise
(integer? -7)  ; => true
(integer? 0.2) ; => false

; even? and odd? check the parity of their argument
(even? 6) ; => true
(odd? 6)  ; => false
; both return false on non-integral numbers
(even? 1.2) ; => false
(odd? 1.2)  ; => false
#+end_src


**** Strings

Strings in Fn are enclosed in double quotes and use the same escape characters
as C/C++, e.g. ~\n~ for newline, ~\r~ for carriage return, ~\t~ for tab. Some
examples include:
#+begin_src fn
; a few examples of strings
"Hello, World!"
""                        ; empty string
"Multi-\nline\nString\n"
#+end_src

The Str function allows strings to be constructed from other types of objects.
#+begin_src fn
(Str 123)     ; => 123
(Str 'symbol) ; => "symbol"
(Str "str")   ; => "str"

; Str can accept multiple arguments
(Str "7 plus 7 is" (+ 7 7))   ; => "7 plus 7 is 14"
(Str "Hello, I'm " 'Jack ".") ; => "Hello, I'm Jack."
#+end_src

Here are some other common functions for working with strings:
#+begin_src fn
; length gives the length of a string
(length "")     ; => 0
(length "str")  ; => 3

; substr creates substrings. It takes 2 or 3 arguments: a
; string followed by a starting position and (optionally)
; an ending position
(substr "Hello" 2)        ; => "llo" (default ending position is
                          ;    the end of the string)
(substr "Hello" 2 3)      ; => "l"
(substr "my string" 0 2)  ; => "my"

; there's a function named reverse
(reverse "gnirts")  ; => "string"

; concat concatenates string
(concat "cat " "test")             ; => "cat test"
; concat accepts more than two arguments
(concat "triple " "cat " "test")   ; => "triple cat test"
#+end_src

Strings in Fn are really just sequences of bytes, hence they can store arbitrary
data. When encoding text, it's recommended to use UTF-8. Future standard library
support for text manipulation will focus on UTF-8.


**** Symbols

Symbols are internalized strings. That is, the symbol's name is hashed, and the
symbol value itself is simply a reference to the hashed value. *This means that
comparisons between symbols as fast as comparisons between integers.* As a
result, symbols are quite useful for making ad-hoc enum types.

Symbols can be created in two ways: by using the ~intern~ function on a string, or
by using the ~quote~ special operator, which is far more common (and more
performant, since then the hashing is done at compile time).
#+begin_src fn
; both of these create a symbol from the string "hello"
(intern "hello")
'hello
; the previous line's syntax is sugar for this
(quote hello)

; symbols can include the same characters as variable names
'dashed-symbol
(quote dashed-symbol) ; again, the line above is exactly the
                      ; same as this (quote ...) form
'am-I-a-symbol?
'%!^$symbol

; symbol-name is the inverse of intern
(symbol-name 'hello)             ; => "hello"
(symbol-name (intern "string"))  ; => "string"
#+end_src

It bears mentioning that ~quote~ can actually do a lot more than creating symbols.
When using quote, keep the following rule in mind:

*quote is guaranteed to return a symbol when followed by a legal variable name.*

There are ways, using escape characters, to use ~quote~ to create symbols which
are not variable names. See [[Quoting]] for this syntax, as well as an explanation
of why ~quote~'s semantics work the way they do.


**** TODO Booleans and ~nil~

The boolean values ~true~ and ~false~, as well as the ~nil~ value, are special
constants in Fn. ~nil~ should exclusively be used to indicate the absence of a
value.

Both ~nil~ and ~false~ are logically false. Any other value is logically true.

Functions whose names end in a question mark should always return ~true~ or ~false~.

- ~and~, ~or~ :: conditional operators


*** TODO Lists and Vecs

Lists and vecs (short for vectors) are sequence types which can hold other
objects. Lists are immutable singley-linked lists. In other words, these are the
usual persistent lists from functional programming. Unlike some dialects of
Lisp, immutability is strictly enforced.

Vecs are also immutable. (I've taken Rich Hickey's persistent vector structure
from Clojure). The key difference between lists and vecs is in their performance
characteristics. Vecs provide faster random access and are fast to extend at the
end. Lists have fast prepend and first-element removal, making them an excellent
choice for stack-like data structures. Both structures are fast to traverse in a
linear fashion. When in doubt, vectors are usually a better choice due to their
fast lookup and constant time.

Lists are created by using the function ~List~, and vecs with the function ~Vec~.

#+BEGIN_SRC fn
; make some lists
(List)               ; empty list
(List 1 2 3 4 5)     ; list of numbers
(List "string" 1 no) ; lists can contain values of different types

; Vec syntax is same as List syntax
(Vec)                ; empty vec
(Vec "gnirts" 0 yes)
#+END_SRC

Some common functions to operate on lists and vectors are:
- ~length~ :: get the length of a list
- ~head~ :: get the first element of a list or vector
- ~tail~ :: get the tail of the list or vector, i.e. a list containing everything
  except the head
- ~reverse~ :: you can guess this one
- ~concat~ :: concatenate two or more sequences (of the same type) end to end
- ~1st, 2nd, 3rd, etc~ :: get the first, second, third, etc element of a
  sequence (up to ~10th~)
- ~->list~ :: convert a sequence or string to a list
- ~->vector~ :: convert a sequence or string to a vector
- ~slice~ :: get a subsequence of a list or vector. (Note: it can be very slow
  taking large subsequences of a list)


** Maps

*Important note 04/26:* Maps are not yet implemented. Sorry! I'll get to it.

*Note:* Maps the data structure are not to be confused with ~map~ the builtin
function (note the lowercase ~m~), which applies a function to the elements of a
sequence.

Maps are key-value stores. Like lists and vecs, maps are immutable and
persistent. (The underlying data structure is a HAMT).


** Tables

*Important note 04/26:* Tables are having their role in Fn dramatically reduced,
and may even get the axe entirely. Turns out mutable hash tables are not the
best for functional programming. Anyway, they were mainly there as a stand-in
for HAMTs, which are coming soon.

Tables are mutable key-value stores, implemented as hash tables with linear
probing and value-based equality testing.

Tables are created using braces (or the equivalent Table function). They must be
passed an even number of arguments. The first, 3rd, 5th, etc are keys, and the
2nd, 4th, 6th are corresponding values. 
#+BEGIN_SRC fn
; here's a table mapping numbers to strings:
{1 "one"
 2 "two"
 3 "three"}
; the above syntax is equivalent to this
(Table 1 "one"
       2 "two"
       3 "three")

; this table maps the symbols a,b,c to various values
{'a "str" 'b 2 'c false}

; keys can also be of mixed types. This table maps empty objects to a symbol
; representing their type
{[] 'List
 {} 'Table  ; here {} is a table acting as a key value for another table
 "" 'Str}
#+END_SRC

Values of the table can be accessed with the ~get~ function:
#+BEGIN_SRC fn
(get {1 "one" 2 "two"} 1) ; => "one"
(get {1 "one" 2 "two"} 1) ; => "two"
#+END_SRC
When the key is a symbol, the special form ~dot~ can be used in place of ~get~.
#+BEGIN_SRC fn
(dot {'hello "world" 'goodbye "moon"} hello) ; => "world"
; the above is equivalent to
(get {'hello "world" 'goodbye "moon"} 'hello)
#+END_SRC
There are two differences between ~get~ and ~dot~. First of all, ~get~ is a normal
function and may be used as such, while ~dot~ is a syntactic form that behaves
differently from a function. Secondly, the argument to ~dot~ is automatically
quoted, i.e. we don't need to put a quote character before the symbol. There is
also special syntax for the ~dot~ form, but that will be introduced after we
introduce variables.

Common functions on tables include:
- ~length~ :: get the length of a table
- ~table-keys~ :: get a list of keys belonging to a table
- ~concat~ :: combine two or more tables. In the case that multiple tables include
  the same key, the last table in the argument list takes precedent.


** TODO Control Flow and Functions

*** Conditional Execution

The conditional control flow primitives are ~if~ and ~cond~.

~if~ takes exactly three arguments: a test expression, an expression to evaluate
if the test is true, and an expression to evaluate if the test is false. In Fn,
~nil~ and ~false~ are considered to be false values, while all others are treated as
~true~.
#+BEGIN_SRC fn
;; if syntax
(if yes 'a 'b)
; => returns 'a
(if no 'a 'b)
; => returns 'b
(if nil 'a 'b)
; => returns 'b
(if (even? x)
    (/ x 2)
    (+ (* 3 x) 1))
; returns "not integer"
#+END_SRC

~cond~ is an alternative conditional syntax which is analogous to "if/else if"
blocks in other programming languages. ~cond~ takes pairs of arguments and treats
the first one as a test. If the test is true, it returns the result of the
second argument in the pair. Otherwise it proceeds to the next pair, returning
~nil~ if the end is reached.

#+BEGIN_SRC fn
;; cond takes pairs of expressions and consequences
(cond
  no   1
  nil  2
  'foo 3
  yes  4)
; => returns 3, because 'foo is the first true value

(defn fizzbuzz (x)
  (cond
    (= (mod x 15) 0) 'FizzBuzz
    (= (mod x 5) 0)  'Buzz
    (= (mod x 3) 0)  'Fizz
    yes              x))
(fizzbuzz 6)  ; = Fizz
(fizzbuzz 7)  ; = 7
(fizzbuzz 45) ; = FizzBuzz
(fizzbuzz 65) ; = Buzz
#+END_SRC


*** Functions and Calls

Function calls have already been shown frequently in the manual prior to this
point. For example, we've seen arithmetic with the functions ~+~, ~-~, ~*~, and ~/~:
#+BEGIN_SRC fn
(+ 1 2 3)      ; => 6
(- (/ 6 2) 3)  ; => 0
(* 17 (- 2 7)) ; => -85
#+END_SRC

As you may have already surmised, in each parenthesized list above, the first
element is the function and the remaining ones are its arguments. All
parenthesized forms in Fn are either special forms, macros, or function calls,
with function calls being the "default" and by far the most common.

Functions are created with the ~fn~ special form, which requires a parameter list
followed by a series of expressions that make up the function's body.

#+BEGIN_SRC fn
; square a number
(def square
  (fn (x)     ; x is bound as a local variable
    (* x x))
; the above is exactly equivalent to
(defn square (x)
  (* x x))

(square 2) ; => 4

; compute sqrt(x^2 + y^2)
(def 2-norm 
  (fn (x y)
    (sqrt (+ (square x) (square y)))))

(2-norm 3 4)  ; => 5
(2-norm 5 12) ; => 13
#+END_SRC

The syntax ~(defn ...)~ is nothing more than a shorten way to say ~(def .. (fn
...))~.

Functions can accept varying numbers of arguments. For this Fn offers *optional
parameters* and *variadic parameters*. Optional parameters have default values that
they assume when not passed explicitly. Variadic parameters, on the other hand,
allow a function to be called with more arguments than it has parameters. The
trailing arguments are passed to the function as a list. These are illustrated
below:

#+BEGIN_SRC fn
; compute the p-norm of (x,y), which is |x^p + y^p|^(1/p). 
; default is p = 2
(defn p-norm (x y (p 2))
  (let xp (** x p)
       yp (** y p))
  (** (+ (abs xp) (abs yp)) (/ 1 p)))

; p-norm accepts either 2 or 3 arguments
(p-norm 3 4)    ; => 5
(p-norm 3 4 2)  ; => 5 (same as default)
(p-norm 3 4 1)  ; => 7 (now p = 1)

; compute x1^2 + x2^2 + ...
(defn sum-squared (& args)
  ; see below for explanation of this line
  (apply + (map square args)))

; accepts any number of arguments
(sum-squared)       ; => 0
(sum-squared 1)     ; => 1
(sum-squared 1 2)   ; => 5
(sum-squared 1 2 4) ; => 21
#+END_SRC

Explanation of the function ~sum-squared~ above: ~map~ applies a function to every
element of the list, in this case squaring each of the arguments. ~apply~,
explained in [[apply]], passes the elements of a list to a function as positional
arguments, in this case summing all the elements of the list.

As you can see, optional parameters, (of which there may be zero or more), are
designated by putting them in parenthesized lists with a default value. Variadic
parameters, (of which their may be zero or one), are designated by the special
symbol ~&~. No additional parameters can follow variadic parameters.

Variadic and optional parameters can be mixed, in which case the variadic
parameter picks up where the optional parameters leave off.


**** Checking for Optional Arguments

Sometimes, it is desirable to know whether an optional parameter was passed, or
just set to the default value. To check whether an optional parameter was
passed, you can use the name of that parameter prefixed with a question mark.
For example,

#+BEGIN_SRC fn
; this returns yes if called with an argument, no otherwise
(defn arg-checker ((x nil))
  (if ?x
      "yes"
      "no"))

(arg-checker)    ; => "no"
(arg-checker 1)  ; => "yes"
#+END_SRC


*** Function Variable Capture

Functions can refer to local variables. Sometimes, a function object might
outlive the scope of the local variable it references. For these cases, Fn
implements *variable capture*.

When the variable's normal lifetime ends, a copy of it is made and saved so that
the function can continue to use that variable during future calls. If multiple
functions refer to the same variable, then they share a reference to it. This
behavior is exhibited below:

#+BEGIN_SRC fn
; simple variable capture example
(with (x 7)
  ; global function get-x captures x
  (def get-x ()
    x))

; x is still accessible even though it's out of scope
(get-x) ; => 7


; variable capture between multiple functions
(with (y 0)
  (def get-y ()
    y)
  (def set-y (v)
    (set! y v)))

; reference to y is shared between get-y and set-y
(get-y) ; => 0
(set-y 17)
(get-y) ; => 17
; i.e. get-y sees the changes made by set-y
#+END_SRC

Variable capture in Fn can be used to implement something analogous to private
members in object-oriented programming languages. This is by letting functions
in a table capture a variable. When the table exits scopes, these functions will
be the only means to access the variable. Here's an example of a counter that
guards access to its value:

#+BEGIN_SRC fn
(defn Counter ()
  "Construct a counter which is initialized to 0."
  ; count is our "private member"
  (let count 0)
  (let self
    ; the functions in this table control access to count
    {'get
     (fn () count)
     'inc
     (fn ()
       (set! count (+ count 1)))
     'reset
     (fn ()
       (set! count 0))})
  self)

; create a counter
(def my-counter (Counter))
(my-counter.get) ; => 0
(my-counter.inc)
(my-counter.inc)
(my-counter.inc)
(my-counter.get) ; => 3
(my-counter.reset)
(my-counter.get) ; => 0
#+END_SRC

As shown above, variable capture allows mutable state to be attached to a
function or group of functions. This can be very powerful. However, as prolific
mutation often leads to bad, buggy programs, this functionality should be used
sparingly, and only after weighing alternative solutions.


*** TODO apply

~apply~ is a built-in function that allows the arguments to a function to be
provided as a list. For example:
#+begin_src fn
(apply + (List 2 4 8)) ; => 14
#+end_src

We can include additional, non-list arguments by putting them between the
function and the list (which is always the final argument).

#+begin_src fn
(apply + 2 (List 4 8)) ; => 14
; above is equivalent to (+ 2 4 8)
#+end_src


*** TODO dollar-fn


** Variables and Mutation

*** TODO Local Variables

Local variables can be created using one of the special operators ~let~, ~letfn~, or
~with~.[fn:let-other-lisp] They all bind variables in the same way, but with
different syntax for programmer convenience. Function parameters are also
treated as local variables within the function body.

Before proceeding, we note that the full story about local variables involves
variable capture semantics, which are covered in [[Variable Capture]]. Variable
capture doesn't affect any of the concepts discussed in the rest of this section.

~let~ is the most elementary way to create a local variable. It defines one or
more new variables in the current lexical environment.

#+BEGIN_SRC fn
;; let binds variables to the given values
(let x 'symbol)
;; multiple definitions can be made in a single let
(let a 16
     b (reverse "string")
     ;; value expressions can refer to variables from earlier in the same let
     c (+ a (length b)))
#+END_SRC

~with~ is similar to ~let~, but rather than creating definitions in the containing
environment, it creates a new lexical environment.

#+BEGIN_SRC fn
;; this creates two variables
(with (a 3
       b 4)
  ;; the body can contain multiple expressions
  (println "hello")
  (+ a b))
;; returns 7
;; the variables a, b do not exist outside of the with body
#+END_SRC

~letfn~ has a streamlined syntax for creating functions, but otherwise behaves
like ~let~.

All local variables can have their value changed with ~set!~. The exclamation
point is because mutation is not to be taken lightly. The syntax for ~set!~ is
like this:

#+BEGIN_SRC fn
(set! var-name new-value)
;; for example
(let var 'hi)
(println var) ;; prints 'hi
(set! var 'lo)
(println var) ;; prints 'lo
#+END_SRC

Note that attempting to ~set!~ a global variable will result in an error.
 
[fn:let-other-lisp] In Fn, the ~with~ operator provides the functionality of what
most Lisp-like languages call ~let~, while Fn's ~let~ is quite different, as it acts
on the surrounding environment.


*** TODO Global Variables

Global variables in Fn are created using ~def~ or ~defn~. E.g.

#+BEGIN_SRC fn
(def my-global 'special-constant)
(def my-other-global (+ 21 69))

(def my-other-global (+ 21 69))
#+END_SRC

~defn~ behaves exactly like ~def~, but has special syntax streamlined for defining
functions.

Global variables are immutable, i.e. they cannot be changed by using ~set!~.
However, by assigning global variables to mutable datatypes or by exploiting
variable capture (discussed in a later section), mutable state can still be
associated to a global variable. This is intended behavior, however, it is not
recommended that you abuse it.


** Loading and Organizing Code (Packages and Namespaces)

To execute code from external sources (i.e. outside the main file), use the
builtin function ~require~.

~require~ takes a single string as an argument. If this string begins with ~./~ or
~/~, it is treated as a filesystem path to either the directory. Otherwise it is
treated as a package name.

Packages are Fn's mechanism for organizing code into loadable modules. ~require~
can locate packages automatically, provided they are somewhere in the search
path, which can be configured via command line options or environment variables.

#+begin_src
(require "./foo.fn")     ; load a file by its relative path
(require "/etc/foo.fn")  ; load a file by its absolute path
#+end_src


*** TODO Packages

A package is simply a directory containing a file named ~__init.fn~. When a
package is loaded using ~require~, the working directory is changed to the package
directory, and ~__init.fn~ is executed.


*** TODO Namespaces


** Namespaces and Import

A *namespace* is a collection of global variable and macro definitions. All Fn
code runs inside of some namespace. External namespaces can be *imported*, which
allows their definitions to be accessed from the current namespace.

Namespaces are identified by a *namespace ID*, which is a symbol segmented by
slash (~/~) characters. It is illegal to have empty segments (i.e. namespace IDs
cannot contain the substring "//"). We call the last part of the namespace ID
its *stem*. Namespace IDs look like paths in a filesystem. This is very
deliberate, and suggestive of the way that ~import~ finds the file corresponding
to a namespace.

*Examples of Namespace IDs:*
#+BEGIN_SRC fn
fn/builtin               ; stem is builtin
fn/internal/io           ; stem is io
my-project/model         ; stem is model
my-project/util/linalg   ; stem is linalg
#+END_SRC

When evaluating code from a file, the namespace stem must always be the stem of
the filename. E.g. ~my-project/model~ must be in a file named ~model.fn~.

The default REPL namespace is ~fn/user~. Fn source code passed in as a
command line argument is also evaluated in this namespace.


*** Namespace Declarations

When you run the ~fn~ command on a file, by default, the namespace ID is set to
the stem of the file by itself. This is obviously no bueno for libraries, as it
would make name collisions inevitable. To add a prefix to a namespace ID, use a
*namespace declaration*. The syntax for namespace declarations is:
#+BEGIN_SRC fn
(namespace <id>)
; e.g.
(namespace fn/builtin)
#+END_SRC

That's it. There can only be one namespace declaration per file, it must be
the first expression in the file (not including comments and whitespace), and
the namespace stem must match the filename stem, e.g. a file named ~model.fn~ must
have the stem of its namespace set to ~model~.

In general, the main file of an application should have a namespace declaration,
as should files intended to be exported as part of a library. In other
situations, the ~import~ form can often automatically deduce the prefix based on
the file's path, and this may lead to code which is slightly easier to refactor.
It's your call.


*** Import

The ~import~ special form allows definitions from an external namespace to be
copied into the current one. There are three different ways to invoke of ~import~,
depending on what you want the imported definitions to be named.

#+BEGIN_SRC fn
(import <namespace-id>)                 ; invocation 1
(import <namespace-id> as <alias>)      ; invocation 2
(import <namespace-id> no-prefix)       ; invocation 3
#+END_SRC

Invocation 1 will name the imported definitions like this:
~<stem>:<definition-name>~.

Using invocation 2 above replaces the stem with ~<alias>~ in the imported
definitions, and invocation 3 drops the prefix entirely as the invocation
suggests.

The clearest way to illustrate this behavior is by example. Say we have a
namespace ~foo/bar/baz~ containing variables named ~bob~ and ~alice~:
#+BEGIN_SRC fn
;;; baz.fn
(namespace foo/bar)
(def alice "Alice")
(def bob "Bob")
#+END_SRC

As shown above, there are three ways to import this namespace. All three cause
the definitions from ~foo/bar/baz~ to be copied into the current namespace.
However, in each case the created bindings will have different names. These
differences are illustrated below:

#+BEGIN_SRC fn
;;; main.fn

;; invocation 1
(import foo/bar/baz)
; variables look like this:
baz:alice
baz:bob

;; invocation 2
(import foo/bar/baz as b)
; variables look like this:
b:alice
b:bob

;; invocation 3
(import foo/bar/baz no-prefix)
; variables are imported directly (no colons)
alice
bob
#+END_SRC


*** Global Identifiers

Each global definition is assigned a unique *global identifier* (global ID) which
allows it to be accessed unambiguously even without being imported. These are of
the form ~#/<namespace-id>:<definition-name>~.

Examples:
#+BEGIN_SRC fn
; these functions lives in fn/builtin
#/fn/builtin:concat
#/fn/builtin:map
#/fn/builtin:filter

; continuation of the example from the previous section
#/foo/bar/baz:alice
#/foo/bar/baz:bob
#+END_SRC

On the other hand, prefixing a symbol with a hash character will cause it to
automatically be expanded into its full global ID by the compiler. This happens
when syntactic sugar is expanded, i.e. before the main compilation step.

#+BEGIN_SRC fn
#concat     ; expands to #/fn/builtin:concat
#map        ; => #/fn/builtin:map
#filter     ; => #/fn/builtin:filter

; assume we're in namespace fn/user/main
#baz:alice  ; => #/fn/user/main:baz:alice
#baz:bob    ; => #/fn/user/main:baz:bob
#+END_SRC


*** TODO Finding Namespace Files


** Quoting and Macros

*** Quoting

"Quoting" refers to the process of converting Fn source code into native Fn
data. This allows us to easily process and manipulate Fn source code using the
same facilities as for normal data.

Quoting is the secret sauce that makes Fn's macro system work. It's the main
reason why Fn has the syntax it has.

The ~quote~ special operator has syntax:
#+BEGIN_SRC fn
(quote <expr>) ;; or, equivalently
'<expr>
#+END_SRC
where ~<expr>~ can be any expression (in fact, it need not be a legal expression
by itself). These two notations are exactly the same. The interpreter expands
the second into the first before evaluation.

The value returned by quote is guaranteed to only consist of lists, symbols,
numbers, and strings. We refer to the latter three as *atoms*. Here are some
examples:
#+BEGIN_SRC fn
'(a b c) ;; returns ['a 'b 'c]
'"string" ;; returns "string"
'(+ a (/ x 2)) ;; returns ['+ 'a ['/ 'x 2]]

''quot ;; is equivalent to
(quote (quote quot)) ;; which returns ['quote 'quot]
#+END_SRC

Note that ~<expr>~ only needs to be syntactically valid (i.e. not freak out the
parser). Illegal expressions can be quoted just fine:
#+BEGIN_SRC fn
'() ;; returns [] (the empty list)
'(2 (3 4)) ;; returns [2 [3 4]]
'(quote) ;; returns ['quote]
#+END_SRC

This makes ~quote~ very handy for creating nested lists of atoms. (~quote~ also has
a big sister named ~quasiquote~, which is covered [[Quasiquotation]], and allows for
much more flexibility).

~quote~ is also the primary way to create symbols. As noted in [[Atomic Types]],
this can lead to problems when we want a symbol whose name is a syntactically
valid number. Adding an escape character to the symbol name designates to the
parser that the token should be read as a symbol rather than a number. In fact,
we can even use this trick to give variables numbers for names:
#+BEGIN_SRC fn
;; probably don't do this
(def \2 3)
2  ;; returns 2
\2 ;; returns 3
#+END_SRC


*** TODO Macro Basics


*** TODO Quasiquotation


*** TODO Macro Hygiene


** Data Types In Depth

This section provides a fairly exhaustive overview of the types built in to Fn.

Fn provides the following builtin data types (type names in Fn are
~Capitalized-Like-This~):

- ~Nil~ :: The special constant ~nil~, used to indicate the absence of a value.
- ~Bool~ :: The boolean values ~true~ and ~false~.
- ~Num~ :: Floating-point numbers. (These are 60-bit floats, obtained by
  truncating the significand of an IEEE double by four bits to fit type
  information).
- ~Sym~ :: Internalized strings, a.k.a symbols. These are essentially strings with
  a fast equality test, useful for ad-hoc enumerations and as keys for tables.
  They are used extensively by the macro system.
- ~Str~ :: Immutable sequences of bytes. When holding text, these are UTF-8
  encoded by default.
- ~List~ :: Immutable singley-linked lists.
- ~Table~ :: Mutable key-value stores.
- ~Func~ :: Function data type

Objects of type Nil, Bool, Num, Sym, and Str are called *atoms*. These are defined
by the fact that they do not contains references to any other objects. List and
Table are *container types*, and Func is the odd-one-out as the *function type*.

Support for user-defined types is not currently implemented. However, a
description of how they will work can be found in [[Structure Types]].

*** Checking Types

Types can be checked at runtime using a variety of builtin type predicates.
These are functions of a single argument which return true or false depending on
its type. These are:

#+BEGIN_SRC fn
bool?
num?
sym?
str?
list?
table?
func?

; examples
(bool? nil)  ; => false
(num? 32)    ; => true
(list? [])   ; => true
#+END_SRC


*** Atomic Types

Here is what the syntax looks like for atoms:

#+BEGIN_SRC fn
; numbers are pretty much what you'd expect. (The same formats as in C++17 are
; accepted).
2
-6
3.14159  ; all numbers are 60-bit floating-point. Not quite doubles
2.0e-6   ; we have scientific notation
0xFf     ; hexadecimal, even!

; strings are enclosed within matched double quotes
"string"
"Fn uses escape codes from C, e.g. \\ \"\n"
""

; symbols are created with a single quote
'sym1
'sym2
; symbols can contain arbitrary characters, but whitespace and syntax characters
; must be escaped with backslashes
'sym\ with\ \"escapes\"

; it will result in a number instead of a symbol. You can get around this 
; with escapes:
'0xb8  ;; this is a number
'\0xb8 ;; this is a symbol
; recommendation: minimize use of symbols whose names are valid numbers

; booleans and nil are called by name
true
false
nil
#+END_SRC

See also subsection [[Quoting]] for more on symbols and the quote operator.


*** Lists

Lists in Fn are what you'd expect for a functional programming language. They're
created using square brackets or by using the ~List~ function.

#+BEGIN_SRC fn
[] ; empty list
['a 'b] ; list of two symbols
[1 'a "str"] ; lists may contain objects of arbitrary type

; The List function behaves identically to square bracket syntax
[1 2 3]
(List 1 2 3)
#+END_SRC

A variety of builtin functions are provided that can operate on lists.

#+BEGIN_SRC fn
; create some demo lists
(def list1 [["str" 2] 'a 'b])
(def list2 [0 2 4 6 8 10])

; head accesses the first element of a list
(head list1) ; => ["str" 2]
(head list2) ; => 0
; tail returns the list without the first element
(tail list1) ; => ['a 'b]

; behavior on empty list:
(head [])    ; => error (empty list has no head)
(tail [])    ; => []

; nth allows random access:
(nth list1 2) ; => 'b
(nth list2 1) ; => 2
(nth list1 5) ; => error (out of bounds)

; length gives the length of a list
(length []) ;=> 0
(length list1) ;=> 3
(length list2) ;=> 6

; cons prepends elements
(cons 2 []) ;=> [2]
(cons 'foo list1) ;=> ['foo ["str" 2] 'a 'b]

; concat concatenates two or more lists
(concat [1 2 3] [4 5 6]) ;=> [1 2 3 4 5 6]
(concat [37] ['foo] ["bar"]) ;=> [37 'foo "bar"]
(concat list2 list1) ;=> [0 2 4 6 8 10 ["str" 2] 'a 'b]

; reverse reverses the direction of a list
(reverse list2) => [10 8 6 4 2 0]
#+END_SRC


*** Tables

Tables are key-value stores. Any type of object may be used as a key or a value,
(note, however, that it takes longer to hash more complicated data structures
since we have to descend on their fields)[fn:key-equality].

Tables are built using braces ~{}~ or the equivalent ~Table~ function. This must be
passed an even number of arguments.

#+BEGIN_SRC fn
{} ;=> empty table
{'key1 4 'key 6} ;=> table with two kv-pairs
(Table 'key1 4 'key 6) ;=> table with two kv-pairs
#+END_SRC

Table elements may be accessed using the builtin function ~get~. When the key is a
constant symbol, dot syntax (or the equivalent ~dot~ special operator) can be
used instead. This is how this looks:

#+BEGIN_SRC fn
(def tab1 {'name "Mr. Table"
           'occupation "Holds data"
           'child {'name "Table Jr." 
                   'occupation "Holds less data"}})
(def tab2 {0 'zero 1 'one 2 'two 3 'three 4 'four})

;; these all return "Mr. Table"
(get tab1 'name)
tab1.name
(dot tab1 name) ; equivalent syntax to the dot expression
;; Note that the symbols in the dot expressions are unquoted. Arguments to dot 
;; must be unquoted symbols or a compilation error occurs.

;; get is more flexible than dot and allows arbitrary key and value expressions
(get tab2 (+ 1 2)) ;=> 'three
(get {'k 'v} 'k) ;=> 'v

;; dot makes it convenient to descend on tables with symbolic key names
tab1.child.name ;=> "Table Jr."
;; equivalent expression:
(dot tab1 child name)
#+END_SRC

Since tables are mutable, the main way to populate them is to use the ~set!~
operator (the same one as for local variables). In this case, the first argument
may be any legal ~get~ or ~dot~ expression on a table.

# TODO: write code examples here
#+BEGIN_SRC fn
#+END_SRC

Lastly, tables size can be checked with ~length~, a list of keys can be retrieved
with ~table-keys~, and two or more tables can be combined with ~concat~ (if any of
the tables have keys in common, the last table in the argument list takes
priority).

[fn:key-equality] Two keys are equal if ~(= k1 k2)~ is true (using the builtin
equality function). For simple data types the meaning of equality is obvious.
Lists and tables are compared componentwise. That is, two lists are equal if and
only if all their respective entries are equal. Two tables are equal if their
key sets are equal (disregarding order), and for each key the corresponding
values in each table are equal.


*** Structure Types

*Note:* User types and metatables are not yet implemented. For now it is
recommended to emulate this behavior by putting methods directly into slots in
the table.

*Structure types* are Fn's mechanism for allowing new data types to be defined on
the fly. Structure types are just normal tables in Fn, and their contents
provides two things:
- a schema describing the fields of the structure
- methods provided by the structure

*Structures* are implemented as tables with particular entries in their
metatables. The *metatable* is a secondary key-value store that is attached to
every table. It can be used to change the behavior of the table as an object.



* TODO Command Line Interface

All functionality is accessed via the ~fn~ command line program.

** TODO Invocation and Namespace Determination

The fn command line tool has the following interface:
#+begin_src
fn [options] [file | --eval string | - ] ARGS
#+end_src

When invoked without any arguments, a repl is started in namespace ~fn/user~.

The main options are:
- ~-r~ :: Start a REPL after evaluating all sources.
- ~--ns <namespace>~ :: Use the specified namespace for evaluation. This also sets
  the namespace for the REPL (which otherwise defaults to ~fn/user~).
- ~--no-rel-imports~ :: Prevents ~import~ from searching for paths relative to the
  filename. See subsection [[Import Search]] for details.
- ~-h~ :: Show help and exit.
There are also two more options that are unlikely to be useful for a typical
user:
- ~-d~ :: Print disassembled bytecode after compiling each expression.
- ~-l~ :: Print LLIR (low-level intermediate representation) before compiling each
  expression.

When an ~--ns~ option is used with a file, that file's namespace name is
overridden by the specified namespace. The file then just acts as a series of
expressions to evaluate. This also prevents import from searching relative to
the file path.

In the absence of an ~--ns~ option, the namespace of a file is determined by the
filename and contents. In particular, the filename stem is used as the short
name. If the file specifies a package, then that package is used, otherwise the
default package ~fn/user~ is used, e.g. a file ~foo.fn~ with no package declaration
would be evaluated in the namespace ~fn/user/foo~.


** Import Search

When the interpreter encounters an import form, it must locate and load the
relevant source file (unless the namespace has already been created, as is the
case for the builtin namespace, or for those namespaces already imported by
another component).

The interpreter has two ways to search for imports. The first way is to use the
package and directory of a file to locate other components, while the second is
to simply use a search path. The search path approach is pretty straightforward;
it can be set using the ~FN_SEARCH_PATH~ environment variable, but by default it
will simply check the Fn library directory on the system (something like
~/usr/lib/Fn/ns~) before giving up.

The first search method mentioned is called relative import search. This is how
it works:
- The interpreter has a notion of a /working directory/. When evaluating a file,
  this is set to the directory containing the file. Otherwise it is the
  directory from which the interpreter was launched.
- The interpreter associates the package of the code being evaluated to the
  working directory. This package is saved by the interpreter as the /root
  package/.
- When an import is performed on any subpackage of the root package (including
  the root package itself), the interpreter will search for import files
  relative to the working directory based on the import name. (It will fall
  back to the search path if this fails).

The specifics of the search algorithm are best explained by example. Suppose I
evaluate a file ~bar.fn~ with package ~baz/foo~. The namespace for the file is
~baz/foo/bar~ and the working directory is the directory of ~bar.fn~, which we'll
write as ~${BAR_DIR}~.

Let's see how imports work in this scenario:
- ~(import baz/foo/oof)~ will cause the interpreter to look for a file
  ~${BAR_DIR}/oof.fn~. This is because the directory ~${BAR_DIR}~ is associated to
  the package ~baz/foo~.
- Similarly, ~(import baz/foo/boom/grop)~ looks for the file
  ~${BAR_DIR}/boom/grop.fn~.
- However, ~(import baz/dop)~ will *not* look for a file named ~${BAR_DIR}/../dop.fn~,
  because ~baz~ is not a subpackage of ~baz/foo~.

Lastly, we make one important notes about imports. Even if a file is located, it
will not be used if it has a package declaration which doesn't match up with the
requested one. In the above example, if we find ~${BAR_DIR}/oof.fn~, but it has a
package declaration placing it somewhere other than ~baz/foo~, then the import
will fail (and we'll end up using the search path).


** REPL

Fn's REPL allows interactive evaluation of code. It supports multi-line
expressions. Optional GNU readline support is planned, but for now, it is highly
recommended that you run the REPL in a wrapper that has command history, such as
rlwrap or Emacs shell-mode.

Additional functionality can be accessed by typing keywords (i.e. symbols whose
names begin with ":"). The available REPL keywords are:

- ~:help~ :: List these options.
- ~:quit~ :: Quit the interpreter. Can also be done by sending EOF with ctrl-d.
- ~:load <filename>~ :: Evaluate a file in the current namespace.
- ~:reimport <namespace>~ :: Redo a namespace import as if it was for the first
  time. Be warned that this will not overwrite the old functions if they've
  already been compiled into a new one.
- ~:ns <namespace>~ :: Switch to the given namespace.

To be interpreted as REPL commands, these cannot be preceded by any whitespace.

At the time of writing, these are not actually implemented in the codebase, but
you can try your luck because there's a chance that this document is out of sync
with my progress.


* Builtin Functions

** ~fn/builtin~

These functions are automatically imported into every namespace upon creation.
They are not all implemented at the time of writing, but a surprising number
are.

*Equality Comparisons*
- ~= (& args)~
  - Returns true if all args are semantically equal
- ~same? (& args)~
  - Behaves the same as ~=~ for numbers, symbols, bools, and the empty
    list. For other types, only returns true if all the arguments correspond to
    the same garbage collector object.


*Type queries:*
- ~number?~, ~string?~, ~list?~, ~table?~, ~function?~, ~symbol?~, ~bool?~
  - These accept a single argument and return true if it has the corresponding
    type, false otherwise.


*Functions on Symbols*
- ~gensym ()~
  - create a nameless symbol which is guaranteed to be unique
- ~intern (string)~
  - create a symbol from a string
- ~symname (symbol)~
  - get a symbol's name as a string

*Functions on Numbers*
- ~+~, ~-~, ~*~, ~/~, ~**~
  - Arithmetic operators. These accept arbitrarily many arguments.
  - ~**~ is exponentiation.
  - Calling with no arguments yields the identity element for the operation.
  - Calling with one argument yields the argument itself for ~+~, ~*~, and ~**~, the
    multiplicative inverse for ~/~, and the additive inverse for ~-~.
  - Underlying operations are performed on IEEE 64-bit floats (with truncated
    significand).
- ~abs~, ~exp~, ~log~
  - Functions of exactly one argument that perform their respective mathematical
    operations.
  - ~log~ is natural log
- ~mod (quantity modulus)~
  - Computes ~quantity~ modulo ~modulus~. The second argument must be an
    integer.
- ~integer?~
  - One argument of any type. True if it's an integer, false otherwise.
- ~floor, ceil~
- ~frac-part~
- ~<~, ~>~, ~<=~, ~>=~
  - The usual quantity comparisons. Accept arbitrarily many args. Always return
    true if 1 or 0 args are passed.

*Functions on Strings*
- ~String (& args)~
  - convert each argument to a string and concatenate them
- ~substring (str start (len -1))~
  - get a substring. Negative length values represent distances from the end of
    the string, with -1 indicating that the substring should go to the end.

*Functions on Lists*
- ~List~
  - Creates a list from its arguments.
- ~cons (hd tl)~
  - prepend ~hd~ to a list ~tl~
- ~head, tail~
  - One argument. Get the head or tail of a list, respectively.
- ~nth (n list)~
  - Get the nth element of a list, indexed from 0.
- ~take,~ ~drop,~ ~split~ ~(n list)~
  - ~take~ takes the first n elements of a list. ~drop~ drops the first n elements
    of a list. ~split~ does both at once and returns a list ~[front back]~, where
    front and back are the two pieces of the list.
- ~take-while, drop-while, split-after (pred list)~
  - ~pred~ is a function of one argument used as a predicate
  - Analogous to take, drop, and split, but instead of splitting after ~n~
    elements, they split on the first element for which ~pred~ fails.

*Functions on Tables*
- ~Table~
  - Accepts an even number of arguments. Treats them as alternating key/value
    pairs and constructs a table.
- ~get (table key)~
  - Get a value from a table. A runtime exception is generated if the table has
    no such key.
- ~get-default (table key (default nil))~
  - Get a value from a table, return default if it's not found.
- ~has-key? (table key)~
  - True or false depending on if key is a key for table.
- ~get-keys~
  - Returns a list of keys to a table. No promises about the order.


*Functions on Collections* 
Strings aren't really collections, but some of these work on them too.
- ~length~
  - Returns length for strings and lists, number of keys for tables.
- ~concat (& args)~
  - Concatenate arguments in the order provided
  - All arguments must have the same type
  - When concatenating tables which have keys in common, the last table in the
    argument list takes precedence.
- ~contains? (coll x)~
  - True if ~(= x y)~ for some ~y~ in the collection, false otherwise.
  - Doesn't work on strings
- ~reverse~
  - This one doesn't work on tables.
- ~empty?~
  - Works on strings, lists, and tables.

*Functions on Bools*
- ~or~, ~and~ (wrappers for the builtins)
- ~not~
- ~nand~
- ~nor~
- ~xor~
- ~xnor~

*Transformations*
- ~apply (fun arg0 arg1 & args)~
  - The last two arguments must be a list and a table, respectively. Calls the
    provided function in the following way: all arguments before the last two
    are passed as positional arguments. The list is expanded and its elements
    are passed as positional arguments. The table is used for keyword arguments.
    Its keys should be symbols (but not keywords).
  - This wraps a builtin operator
- ~partial (fun & args)~
  - partially apply a function
- ~comp (fun & funs)~
  - compose the provided functions
- ~map (fun & colls)~
  - we all know ~map~
  - as a bonus, it also works on tables
- ~maprev (fun & colls)~
  - like map, but only for lists and the resulting list is reversed
  - this is faster than map
- ~foldl (fun init coll)~
  - perform a left fold
  - ~fun~ accepts arguments ~(accumulator input)~
- ~foldr (fun init coll)~
  - perform a right fold
  - ~fun~ accepts arguments ~(input accumulator)~
- ~filter (fun coll)~
  - works on lists and tables

*Macros*
- ~->~, ~->>~ 
  - Threading macros. These work like they do in Clojure. No time now to type a
    description here.

*Error Generation*
- ~error (message)~
  - Stops execution and emits the provided error message.


* FFI

Fn will provide an FFI that works in the following way:
- Create C source file that includes the ~fnffi.h~ header, which provides functions
  for manipulating Fn values.
  - The functions intended to be called from Fn must have a particular type
    signature.
- Compile the file into a shared library.
- Back in Fn, use the namespace ~fn/ffi~ to import functions by name from the
  shared library.
