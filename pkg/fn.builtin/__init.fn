(namespace fn/builtin)

(import fn/internal int)

(def list? int:list?)
; (def empty? int:empty?)
(def symbol? int:symbol?)

(def = int:=)
(def <= int:<=)
(def >= int:>=)
(def + int:+)
(def - int:-)
(def * int:*)
(def / int:/)
(def ** int:**)
(def mod int:mod)

(def ceil int:ceil)

;(def head int:head)
; (def tail int:tail)
; (def cons int:cons)

(def set-metatable int:set-metatable)
(def metatable int:metatable)
(def Table int:Table)

(def require int:require)

(def println int:println)

(def macroexpand-1 int:macroexpand-1)

(def not
     (fn (p)
       (if p no yes)))

(def List
     (set-metatable
      {'__call (fn (self & args) args)}
      {'head int:head
       'tail int:tail
       'empty? int:empty?
       'cons (fn (self y) (int:cons y self))
       ; 'map (fn (self))
       ; 'filter (fn ( self))
       ; 'divide (fn (self))
       ; 'method (fn (self))
       ; 'fuck (fn (self))
       }))

(int:def-list-meta List)

(defmacro head (x) [''head x])
(defmacro tail (x) [''tail x])
(defmacro empty? (x) [''empty? x])
(defmacro cons (y x) [''cons x y])

; foldl is needed early to bootstrap some other functions
(def foldl
  (fn (f init list)
    (let iter
         (fn (acc rem)
           (if (empty? rem)
               acc
               (iter (f acc (head rem))
                     (tail rem)))))
    (iter init list)))

(def reverse
  (fn (list)
    (foldl (fn (x y) (cons y x)) [] list)))

(def length
  (fn (list)
    (foldl (fn (l r) (+ l 1)) 0 list)))

(def concat
  (fn (& lists)
    (let concat2
         (fn (l r)
           (foldl (fn (x y) (cons y x)) r (reverse l))))
    (foldl (fn (x y) (concat2 y x)) [] (reverse lists))))

(require "./special.fn")
(require "./list.fn")
; (require "./quasiquote.fn")

