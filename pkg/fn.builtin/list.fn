(namespace fn/builtin)

; (defmacro letfn (name args & body)
;   (List 'do-inline
;         (List 'let name
;               (cons 'fn
;                     (cons args body)))))

(defmacro letfn (name args & body)
  (List 'do-inline
        (List 'let
              name
              (concat (List 'fn args) body))))

; (defmacro defn (name args & body)
;   (letfn valid-list? ()         ; validate a list name
;     (and (= (length name) 2)
;          (symbol? (head (tail name)))
;          (list? (head name))
;          (= (length (head name)) 2)
;          (= (head (head name)) 'quote)))
;   (cond
;     (list? name)
;     (if (valid-list?)
;         `(set! (. ,(head (tail name)) ,(head name))
;                (fn ,args ,@body))
;         (error "Invalid name in defn"))

;     (symbol? name)
;     `(def ,name
;           (fn ,args ,@body))

;     yes
;     (error "Invalid name in defn"))
;   )

(defn nth (n list)
  (if (<= n 0)
      (head list)
      (nth (- n 1) (tail list))))

; (defn ('empty? List) (self)
;   (= self []))

; (defn ('head List) (self)
;   (int:head self))

; (defn ('tail List) (self)
;   (int:tail self))

(defn any (test? list)
  (letfn iter (rem)
    (if (empty? rem)
        no
        (if (test? (head rem))
            yes
            (iter (tail rem)))))
  (iter list))

(defn map-reverse (f & lists)
  (letfn iter (acc tails)
    (if (any empty? tails)
        acc
        (do
          (let v
               (apply f
                      (reverse (foldl (fn (x y) (cons (head y) x))
                                      []
                                      tails))))
          (iter (cons v acc)
                (reverse (foldl (fn (x y) (cons (tail y) x))
                                []
                                tails))))))
  (iter [] lists))

(defn map (f & lists)
  (reverse (apply map-reverse f lists)))
