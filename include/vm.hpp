// vm.hpp -- value representation and virtual machine internals

#ifndef __FN_VM_HPP
#define __FN_VM_HPP

#include "allocator.hpp"
#include "base.hpp"
#include "compile.hpp"
#include "parse.hpp"
#include "table.hpp"
#include "values.hpp"

#include <filesystem>
#include <forward_list>
#include <vector>

namespace fn {

namespace fs = std::filesystem;

// global_env keeps track of currently-loaded chunks and namespaces
struct global_env {
private:
    value root_ns;
    value builtin_ns;
    allocator* alloc;
    vector<code_chunk*> loaded_chunks;

public:
    // this creates the root namespace hierarchy including the fn.builtin
    // namespace.
    global_env(allocator* use_alloc);
    ~global_env();

    allocator* get_alloc();
    value get_root_ns();
    value get_builtin_fs();

    // create a namespace without importing builtin functions. The ns variable
    // will still be set
    value add_empty_namespace(bool* existed, namespace_id ns_id);
    // create a namespace with builtin imports
    value add_namespace(bool* existed, namespace_id ns_id);
    code_chunk* add_chunk(value ns);
};


// virtual_machine stack size limit (per call frame)
constexpr stack_addr STACK_SIZE = 255;

// This structure includes a pointer to the previous call frame, so it is
// actually a linked list representing the entire call stack.
struct call_frame {
    // call frame above this one
    call_frame* prev;
    // return address
    bc_addr ret_addr;
    // base pointer (i.e. offset from the true bottom of the stack)
    u32 bp;
    // the function we're in. nullptr on the top level.
    function* caller;
    // the number of arguments we need to pop after exiting the current call
    local_addr num_args;

    call_frame(call_frame* prev,
            bc_addr ret_addr,
            u32 bp,
            function* caller,
            local_addr num_args=0)
        : prev(prev)
        , ret_addr(ret_addr)
        , bp(bp)
        , caller(caller)
        , num_args(num_args) {
    }
};

// The architecture here is that the virtual_machine object manages a collection
// of vm_threads. When a vm_thread finishes executing, it will leave behind some
// exit state, which can indicate that it's done, that it requires an import, or
// that it. Comment: perhaps the vm_thread object can replace the
// virtual_machine one, and the interpreter can handle the coordination. It
// would avoid the need for the separate import_manager class, because we could
// simply terminate with a WAITING_FOR_IMPORT status.

// possible statuses for a vm_thread
enum vm_status {
    vs_stopped,
    vs_running,
    vs_waiting_for_import,
    vs_error
};

// WARNING: despite the name, vm_threads cannot truly be run in parallel (until
// the allocator and global_env are made threadsafe).

// vm_thread represents a single thread of the interpreter, so it has its own
// instruction pointer, stack, etc. This is where the bytecode execution logic
// is.
struct vm_thread {
private:
    // These are weak references to objects maintained by the interpreter.
    global_env* glob;
    allocator* alloc;
    code_chunk* toplevel_chunk;
    value root_ns;

    // current execution status
    vm_status status;
    // set when the execution status is set to vs_error
    string error_message;
    // set when the execution status is vs_waiting_for_import
    value pending_import_id;

    // instruction pointer and stack
    bc_addr ip;
    call_frame* frame;
    root_stack* stack;

    // last pop; used to access the result of the last expression
    value lp;

    // peek relative to the top of the stack
    value peek(stack_addr offset=0) const;
    // get a local value from the current call frame
    value local(local_addr l) const;
    // set a local_addr value
    void set_local(local_addr l, value v);

    // internalize a symbol by name
    value get_symbol(const string& name);

    void add_global(value name, value v);
    value get_global(value name);

    // attempt an import without escaping to interpreter
    optional<value> try_import(const namespace_id& ns_id);
    // perform an import using the top of the stack as the id. If the target
    // namespace is not already loaded, then this will cause execution to halt
    // with the waiting_for_import status.
    void do_import();

    // stack operations
    value pop();
    void pop_times(stack_addr n);
    void push(value v);

    // returns the next addr to go to
    bc_addr call(working_set& use_ws, local_addr num_args);
    bc_addr apply(working_set& use_ws, local_addr num_args);

public:
    // initialize the virtual machine
    vm_thread(global_env* use_glob, code_chunk* use_chunk);
    ~vm_thread();

    vm_status check_status() const;
    const string& get_error_message() const;
    value get_pending_import_id() const;

    // step a single instruction
    void step();
    // execute instructions (stops if the end of the generated bytecode is reached)
    void execute();
    // get the instruction pointer
    bc_addr get_ip() const;

    // get the last popped value (null if there isn't any)
    value last_pop() const;

    code_chunk* cur_chunk() const;
    code_chunk* get_toplevel_chunk();
    allocator* get_alloc();
    symbol_table* get_symtab();

    // raise an exception of type fn_error containing the provided message
    void runtime_error(const string& msg) const;
};


// disassemble a single instruction, writing output to out
void disassemble_instr(const code_chunk& code, bc_addr ip, std::ostream& out);

void disassemble(const code_chunk& code, std::ostream& out);


}

#endif
