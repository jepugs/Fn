(defn Kons (hd tl)
  {'class 'Kons 'empty false 'hd hd 'tl tl})
(def E-Kons {'class 'Kons 'empty true 'hd nil 'tl nil})
(defn kreverse (lizt)
  (letfn iter (acc rem)
    (if rem.empty
        acc
        (iter (Kons rem.hd acc) rem.tl)))
  (iter E-Kons lizt))
(defn ktake (n lizt)
  (letfn iter (acc n rem)
    (if (or rem.empty (<= n 0))
        (kreverse acc)
        (iter (Kons rem.hd acc) (- n 1) rem.tl)))
  (iter E-Kons n lizt))
(defn kons->cons (lizt)
  (letfn iter (acc rem)
    (if rem.empty
        (reverse acc)
        (iter (cons rem.hd acc) rem.tl)))
  (iter [] lizt))
(defn cons->kons (list)
  (letfn iter (acc rem)
    (if (empty? rem)
        (kreverse acc)
        (iter (Kons (head rem) acc) (tail rem))))
  (iter E-Kons list))
(defn kfilter (pred lizt)
  (letfn iter (acc rem)
    (cond
      rem.empty (kreverse acc)
      (pred rem.hd) (iter (Kons rem.hd acc) rem.tl)
      otherwise (iter acc rem.tl)))
  (iter E-Kons lizt))
