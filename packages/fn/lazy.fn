(namespace fn/lazy)

(def Lazy-List-Meta
  {'force (fn (self)
            ((get self 'force) self))
   'empty? (fn (self)
             (= ((get self 'force) self) nil))
   'head (fn (self)
           (head ((get self 'force) self)))
   'tail (fn (self)
           (head (tail ((get self 'force) self))))
   'map (fn (self fun)
          (lmap fun self))
   'filter (fn (self fun)
             (lfilter fun self))})

(defn Lazy-List (fun)
  (with-metatable Lazy-List-Meta
    {'force (fn (self)
              (let val (fun))
              (set! (get self 'force)
                    (fn (self) val))
              val)}))

(defn list->lazy (list)
  (if (empty? list)
      (Lazy-List (fn () nil))
      (Lazy-List $[(head list)
                   (list->lazy (tail list))])))

(defn lazy->list (lazy)
  (letfn iter (acc rem)
    (if (rem.empty?)
        (reverse acc)
        (iter (cons (rem.head) acc)
              (rem.tail))))
  (iter [] lazy))

(defn lcons (hd lazy)
  (Lazy-List (fn ()
               [hd lazy])))
(defmacro lcons (hd tl)
  `(Lazy-List (fn ()
                [,hd ,tl])))

(defn drop-nth (n lazy)
  (cond
    (lazy.empty?)  lazy
    (<= n 0)       (lazy.tail)
    otherwise      (Lazy-List $[(lazy.head)
                                (drop-nth (- n 1) (lazy.tail))])))

(defn lconcat (l1 l2)
  (if (l1.empty?)
      l2
      (Lazy-List
       $[(head l1)
         (lconcat (tail l1) l2)])))

(defn ldrop (n lazy)
  (if (or (lazy.empty?) (<= n 0))
      lazy
      (ldrop (- n 1) (lazy.tail))))

(defn drop-every (n lazy)
  (letfn next ()
    (let x (drop-every n (drop n lazy)))
    [(head x) (tail x)])
  (lconcat (list->lazy (ltake (- n 1) lazy))
           (Lazy-List next)))

(defn ltake (n lazy)
  (letfn iter (acc m rem)
    (if (or (rem.empty?) (<= m 0))
        (reverse acc)
        (iter (cons (rem.head) acc)
              (- m 1)
              (rem.tail))))
  (iter [] n lazy))

; nonnegative integers
(def N>=0
  (with (next-int
         $(Lazy-List (fn ()
                       [$0 (next-int (+ $0 1))])))
    (next-int 0)))

(defmacro defer-list (expr)
  (let x (gensym))
  `(Lazy-List (fn ()
                (with (,x ,expr)
                  [(head ,x) (tail ,x)]))))

(defn lmap (fun lazy)
  (if (lazy.empty?)
      (list->lazy [])
      (lcons (fun (head lazy))
             (lmap fun (tail lazy)))))

(defn unbox-lazy (lazy)
  [(head lazy) (tail lazy)])

(defn lfilter (pred lazy)
  (letfn next (rem)
    (cond
      (rem.empty?) rem
      (pred (head rem))
        (lcons (head rem)
               (Lazy-List $(unbox-lazy (next (tail rem)))))
      otherwise (next (tail rem))))
  (next lazy))

; sequence of prime numbers
(do
  (let init-primes (list->lazy [2 3 5 7])
       candidates
       (with (next-pair
              (fn (x)
                (lcons (- (* 6 x) 1)
                       (lcons (+ (* 6 x) 1)
                              (next-pair (+ x 1))))))
         (next-pair 2)))
  (letfn prime-test? (x)
    (let max (ceil (** x 0.5)))
    (letfn iter (rem)
      (let n (head rem))
      (cond
        (= (mod x n) 0) false
        (>= n max) true
        otherwise (iter (tail rem))))
    (iter primes))
  (def primes
    (lconcat init-primes
             (Lazy-List (fn ()
                          (let next (filter prime-test? candidates))
                          [(head next) (tail next)])))))

(defn factor (n)
  (if (not (integer? n))
      (error "Can only factor integers.")
      nil)
  (letfn factor-recur (acc val rem-primes)
    (let p (head rem-primes))
    (cond
      (= val 1) (reverse acc)
      (= (mod val p) 0)
        (factor-recur (cons p acc) (/ val p) rem-primes)
      (>= p (** val 0.5))
        (reverse (cons val acc))
      otherwise
        (factor-recur acc val (tail rem-primes))))
  (cond
    (= n 0)    [0]
    (< n 0)    (factor-recur [-1] (- n) primes)
    otherwise  (factor-recur [] n primes)))

; remove first element = to elt
(defn lremove (elt seq)
  (cond
    (empty? seq)       empty
    (= elt (head seq)) (tail seq)
    otherwise          (lcons (head seq)
                              (lremove elt (tail seq)))))
