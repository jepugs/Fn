(package fn)

(defn even? (x)
  (= (mod x 2) 0))
(defn odd? (x)
  (= (mod x 2) 1))

(defn and (& args)
  (letfn iter (prev rem)
    (if (empty? rem)
        prev
        (and (head rem)
             (iter (head rem) (tail rem)))))
  (if (empty? args)
      true
      (and (head args)
           (iter (head args) (tail args)))))

(defn or (& args)
  (letfn iter (prev rem)
    (if (empty? rem)
        prev
        (or (head rem)
            (iter (head rem) (tail rem)))))
  (if (empty? args)
      false
      (or (head args)
          (iter (head args) (tail args)))))

(defn nand (& args)
  (not (apply and args {})))
; (defmacro nand (& args)
;   `(not (and ,@args)))
(defn nor (& args)
  (not (apply or args {})))
; (defmacro nor (& args)
;   `(not (or ,@args)))

(def otherwise true)

(defn take (n list)
  (letfn iter (acc rem i)
    (if (or (empty? rem)
            (>= i n))
        (reverse acc)
        (iter (cons (head rem) acc)
              (tail rem)
              (+ i 1))))
  (iter [] list 0))

(defn drop (n list)
  (if (or (empty? list) (= n 0))
      list
      (drop (- n 1) (tail list))))

(defn split (n list)
  (letfn iter (acc rem i)
    (if (or (empty? rem)
            (>= i n))
        [(reverse acc) rem]
        (iter (cons (head rem) acc)
              (tail rem)
              (+ i 1))))
  (iter [] list 0))

(defn take-while (pred list)
  "Take elements from a list as long as pred is true."
  (letfn iter (acc rem)
    (if (or (empty? rem)
            (not (pred (head rem))))
        (reverse acc)
        (iter (cons (head rem) acc)
              (tail rem))))
  (iter [] list))

(defn drop-while (pred list)
  (if (or (empty? list)
          (not (pred (head list))))
      list
      (drop-while pred (tail list))))

(defn split-after (n list)
  "Take elements from a list as long as pred is true."
  (letfn iter (acc rem)
    (if (or (empty? rem)
            (not (pred (head rem))))
        [(reverse acc) rem]
        (iter (cons (head rem) acc)
              (tail rem))))
  (iter [] list))

(defn reverse (list)
  (letfn iter (acc rem)
    (if (empty? rem)
        acc
        (iter (cons (head rem) acc) (tail rem))))
  (iter [] list))


(do
  (let substring-internal substring)
  (defn substring (str start (len -1))
    (substring-internal str start len))
  )

(defn contains? (coll x (test #/fn/builtin:=))
  (letfn list-iter (rem)
         (if (test x (head rem))
             true
           (list-iter (tail rem))))
  (letfn table-iter (rem-keys)
         (if (test (get coll (head rem-keys)) x)
             true
           (table-iter (tail rem-keys))))
  (cond
   (list? coll)   (list-iter coll)
   (table? coll)  (table-iter (get-keys coll))
   otherwise      (error "contains? argument must be a list or table.")))

; (defn apply (fun arg0 & args)
;   (letfn iter (acc rem)
;     (if (empty? (tail (tail rem)))
;         [(concat (reverse acc) (head rem))
;          (head (tail rem))]
;         (iter (cons (head rem) acc)
;               (tail rem))))
;   (let result (iter [] (cons arg0 args)))
;   (apply fun (nth 0 result)))

(defn partial (fun & args)
  (fn (& more-args)
    (apply fun
           (concat args more-args))))

(defn comp (fun & funs)
  (if (empty? funs)
      fun
      (fn (& args)
        (fun (apply (apply comp funs)
                    args)))))

(defmacro -> (val & args)
  (letfn f (acc in)
    (if (list? in)
        (cons (head in)
              (concat [acc] (tail in)))
        [in acc]))
  (foldl f val args))

(defmacro ->> (val & args)
  (letfn f (acc in)
         (if (list? in)
             (concat in [acc])
           [in acc]))
  (foldl f val args))

(defn map (f list)
  (reverse (maprev f list)))

; map, but returns reversed list. This is faster than map
(defn maprev (f list)
  (letfn iter (acc rem)
    (if (empty? rem)
        acc
        (iter (cons (f (head rem)) acc)
              (tail rem))))
  (iter [] list))

(defn foldl (f init list)
  (letfn iter (acc rem)
         (if (empty? rem)
             acc
           (iter (f acc (head rem)) (tail rem))))
  (iter init list))

(defn foldr (f init list)
  (letfn iter (acc rem)
    (if (empty? rem)
        acc
        (iter (f (head rem) acc) (tail rem))))
  (iter init (reverse list)))

(defn filter (pred list)
  (letfn iter (acc rem)
    (println "itebr")
    (cond
      (empty? rem) (reverse acc)
      (pred (head rem)) (iter (conj (head rem) acc)
                              (tail rem))
      true (iter acc (tail rem))))
  (println list)
  (iter [] list))

(defn macro-assert (condition msg)
  (if (not condition)
      (error msg)
      nil))

(defn mapcat (fun list)
  (apply concat (map fun list)))

(defmacro match (& clauses)
  (macro-assert (= 2 (length clauses)))
  (let bindings (pattern-bindings (head clauses) (nth 1 clauses))
       names (head bindings)
       body (nth 1 bindings))
  `(do (let ,@(mapcat $`(,$ nil) bindings))
     ,(nth 1 values)
     ,(nth 1 clauses)))


(defn list-range (start stop)
  (letfn iter (acc i)
    (if (< i start)
        acc
        (iter (cons i acc) (- i 1))))
  (iter [] stop))

;; Wrap a bunch of the builtin foreign functions to expand functionality. This
;; is a bit of a hack, but it lets us define simpler versions of these functions
;; internally without polluting the namespace.
(do
  (let list-head head)
  (let list-tail tail)
  (let list-empty? empty?)
  (let list-nth nth)
  ; this is like a prototype for protocols. Every table containing head, tail,
  ; empty?, and conj methods can be treated as a sequence
  (defn head (seq)
    (if (list? seq)
        (list-head seq)
        (seq.head)))
  (defn tail (seq)
    (if (list? seq)
        (list-tail seq)
        (seq.tail)))
  ; (defn empty? (seq)
  ;   (if (or (list? seq)
  ;           (table? seq))
  ;       (list-empty? seq)
  ;       (seq.empty?)))
  (defn conj (elt seq)
    (if (list? seq)
        (cons elt seq)
        (seq.conj elt)))
  (defn conj-to-front? ()
    (if (list? seq)
        true
        (seq.conj-to-front?)))
  (letfn new-nth (n seq)
    (letfn iter (n rem)
      (if (= n 0)
          (head rem)
          (iter (- n 1) (tail rem))))
    (iter n seq))
  (defn nth (n seq)
    (if (or (not (integer? n))
            (< n 0))
        (error "Invalid index in call to nth.")
        nil)
    (if (list? seq)
        (list-nth n seq)
        (new-nth n seq)))
  ; implementing all the above will give you nth, map, filter, foldl, etc. You
  ; can override those though.
  (let seq-map map)
  (defn map (pred seq)
    (if (and (table? seq)
             (has-key? seq 'map))
        (seq.map pred)
        (seq-map pred seq)))
  (let seq-filter filter)
  (defn filter (pred seq)
    (if (and (table? seq)
             (has-key? seq 'filter))
        (seq.filter pred)
        (seq-filter pred seq))))


