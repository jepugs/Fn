* fn Version 0 Language Specification

This document is an attempt to formally specify fn as it stands in version 0. There are certain
features found in more mature programming languages which require a lot of labor to implement. fn
Version 0 aims to cut down on these features so that the resultant language is relatively easy to
implement, while still being usable for writing actual programs.

** TODO Implementation checklist

*Special forms*
- [X] and
- [X] or
- [ ] cond
- [X] if
- [ ] def
- [ ] set
- [ ] let
- [ ] fn
- [ ] quote
- [ ] dot
- [ ] import

*Built-in Functions*
- [ ] string
- [ ] print, println

** Glossary

- *Function* :: Functions in fn are subroutines which accept arguments and produce a return value.
  They are allowed to have side effects.
- *General object* :: A general object is a hash table which accepts either strings or (positive)
  integers as keys. (It should be implemented using a hybrid data structure similar to Lua's
  tables).
- List :: Lists in fn are singley-linked and implemented using cons cells.
- *Module* :: A general object created using the import operator.
- Object :: In a common abuse of terminology, the term *object* may refer either to any *value* or
  specifically to one of type *general object* depending on the context.
- *Primitive* :: A *primitive* value is one which is not a general object. The primitive types are
  number, symbol, boolean, null, string, function, and list. Note that this is in contrast to
  programming languages such as Java, where primitive values only include those which are not
  pointers.
- *Type* :: (of a value). The symbol identifying the structure of data referenced by a value
- *Value* :: *Value* is the term of choice to refer to the results of evaluation in fn.


* Program Structure and Syntax

A program in fn is a sequence of expressions. Semantically, expressions are evaluated in the order
they appear. Every expression in fn is guaranteed to return a value.

Broadly, there are two types of expressions:
- atoms :: are expressions consisting of a single token. Specifically, these are string and number
  literals and unquoted symbols (i.e. ~true~, ~false~, ~null~, or a variable name)
- *compound expressions* :: semantically, these are sequences of *subexpressions*. The first such
  subexpression is referred to the *operator* and the remaining ones as the *arguments* or *operands*

Every expression in fn can be normalized to have a syntactic form consisting entirely of parentheses
and atoms separated by symbols. Specifically, all compound expressions can be represented via the
form:
#+BEGIN_SRC fn
(operator operands ...)
#+END_SRC

For example, the following expression
#+BEGIN_SRC fn
(map type-of [1 true 'three])
#+END_SRC
is expanded to
#+BEGIN_SRC fn
(map type-of (list true (quote three)))
#+END_SRC
for evaluation.

We can further divide compound expressions into two groups based upon their operator: function calls
and *special forms*. Special forms are the built-in language facilities that let you do things like
managing variables. Every special form has a symbol for an operand. The symbols which denote special
forms are:
- and, or :: logical operators with short-circuiting
- cond, if :: logical control-flow operators
- do :: execute several expressions in order
- *def*, *set* :: variable definition and mutation
- *dot* :: used to access the fields of an object
- *import* :: import another file as a module
- *let* :: creates local variables
- *fn* :: create anonymous functions
- quote :: used to create symbols

In addition, the following symbols are reserved for use as special forms in future versions:
- quasi-quote, unquote, unquote-splicing
- dollar-fn
- defmacro
- defsym
- def*
- macrolet
- symlet

*Note:* It is syntactically possible to create the *empty expression*, ~()~, which has no operator. On its
own this expression results in an evaluation error, but it is legal as a subexpression in certain
contexts.

** Syntax for atoms

Strings start and end with quotation marks ~"~ and use the same syntax as C++20 for escape characters.
Numbers use the same syntax as C++20 as well, including support for scientific notation.

The following characters are special and may not occur in symbols unless they are escaped:
~`@$()[]{}\;'",.~ . If any of these characters are encountered, they will trigger the scanner to start
reading a new token (i.e. they terminate the preceding symbol). This makes whitespace unnecessary in
many situations, for example:
#+BEGIN_SRC fn
(function1'sym(+ x"y"))
;; perfectly equivalent to
(function1 'sym (+ x "y"))
#+END_SRC
However, this style of coding is hideous and hard to read, even with highlighting, so successive
expressions should always be separated by whitespace.

The escape character is the backslash ~\~. This may be used to include the aforementioned special
characters in the symbol name.

** Other syntax characters

As we have seen in prior examples, parentheses may be used as grouping operators to denote compound
expressions. Similarly, square brackets and braces may be used to create lists and objects,
respectively:
#+BEGIN_SRC fn
[arg1 arg2 arg3] ; expands into
(list arg1 arg2 arg3)

{k1 v1 k2 v2} ; expands into
(object k1 v1 k2 v2)
#+END_SRC

When followed by a symbol, the quote ~'~ character expands to a quote form:
#+BEGIN_SRC fn
'symbol-name ;expands to
(quote symbol-name)
#+END_SRC

When two or more symbols are separated by dots, a ~dot~ form is generated
#+BEGIN_SRC fn
obj.key ;expands to
(dot obj key)
a.b.c ;expands to
(dot a b c)
#+END_SRC

** Grammar

Let the nonterminals <symbol>, <string>, and <number> denote symbol, string, and number expressions
respectively, and <dot> denote one or more symbols delimited by dots, (e.g. "obj.key" or "a.b.c").

#+BEGIN_SRC
expr ::= '(' expr* ')"
       | '[' expr* ']'
       | '{' expr* '}'
       | '\'' <symbol>
       | <dot>
       | <symbol> | <string> | <number>
#+END_SRC


* Values

*Value* in this document refers to the units of data in fn's evaluation model. (Although the term
*object* is used synonymously in certain contexts, throughout this section "object" specifically refers
to values with the structure of a *general object*, i.e. key-value stores).

Every value in fn is of one of the types described below. The only compound structures fn provides
for organizing data (not considering strings) are singley-linked lists and *general objects*, the
latter of which are hash tables taking all values as keys.

** Types and Objects

Every value in fn has a type associate with it. To be precise, the *type* of a value is a
value itself, specifically one of these symbols:

- null :: the special constant null
- bool :: the special constants true and false
- num :: numbers (61-bit signed floats)
- symbol :: symbols, which are internalized strings
- string :: strings of bytes. By default assume UTF-8 encoding for text strings.
- list :: singley-linked lists
- function :: functions
- *object* :: general objects, which are hash tables with string keys

** Notation for Values

The notation used for values in this document is largely the same one used in fn source code and
emitted by fn's built-in ~string~ and ~print~ functions.

Strings and numbers are denoted as they would appear in code. That is, strings appear between double
quote characters with escape characters as in C++ and numbers use notation for floats from C++.
Examples: ~"string"~, ~"two line\nstring"~, ~-25~, ~+1.90e3~.

Symbols are denoted with a single quote preceeding the symbol name. Single characters which are not
normally contained in symbol names are escaped with a single backslash. Examples: ~'symbol~, ~'var~,
~'symbol\ with\ escape\(d\)\ chars~.

~true~, ~false~, and ~null~ (the special constants) are denoted exactly like that.

Lists are denoted by square brackets containing whitespace-delimited values. Thus the empty list is
~[]~. Examples: ~['one 'two "three"]~, ~[1 2 3]~, ~['singleton]~.

Finally, objects are denoted using braces containing an even number of values. Every two consecutive
values correspond a single property (a key-value pair) of the object. Examples: ~{'a 12 'b "str"}~ is
an object with two properties, ~{'id 1 'contents {"k1" 1 "k2" 0}}~ is an object with two properties,
one of which is another object of two properties.

This leaves only functions, for which there is not an especially good textual representation. Thus
we default to using ~<function>~ to represent all functions.

** Code as Values

This simplicity of fn's syntax allows one to create a nice correspondence between syntactically
valid fn expressions and fn values by using lists to denote compound expressions and primitive
values to denote numbers, strings, and symbols. This will be utilized in future versions of fn to
specify a macro system similar to the ones featured by other dialects of Lisp.


* Evaluation Model

Programs in fn consist of a series of expressions, called the *top-level expressions*. When a program
is run, these are *evaluated* one at a time in the order in which they appear. Every expression in fn
returns some value, however in the case of top-level expressions these are ignored.

The process of evaluation may induce changes in the execution environment. These *side-effects* of
evaluation may be roughly categorized as either *internal*, for those which affect the values of
variables in fn, or *external*, for those which cause I/O to happen on the host computer. For the
purpose of this section, we will restrict ourselves to mainly focus on internal side effects, e.g.
variable definitions. External side effects are accomplished via foreign function calls and
generally can't affect the variable environment, so these do not really have much bearing on any
formal description of fn's evaluation model.

As outlined in the section Program Structure and Syntax, every expression in fn is either an atom or
a compound expression consisting of an operator and an operand. In the latter case, the operator
solely determines the manner in which the expression is evaluated. If it is anything other than one
of the designated symbols denoting a special form, then the expression will be evaluated as a
function call. Thus we may describe most of fn's evaluation semantics by simply describing the
required arguments and behavior of each special form in turn. This leaves only atom evaluation
(which is fairly simple) and function calling.

In order to make this section more readable, special forms are divided up logically based on their
function. In order to aid in reference, this is a list of special forms and core functions by the
subsection in which they are described:

- Variables :: Special forms: ~def~, ~let~, ~set.~
- Functions and Function Calls :: Special forms: ~fn~. Functions: ~apply~.
- Data Structures :: Special forms: ~dot~. Functions: ~get~, ~head~, ~tail~, ~list~, ~object~, ~string~, ~cons~,
  ~extend~
- Logic and Control Flow :: Special forms: ~and~, ~cond~, ~do~, ~if~, ~or~. Functions: ~not~.
- Importing Other Sources :: Special forms: ~import~.
- Quoting :: Special forms: ~quote~.
# - Metaprogramming Via Macros ::

** Evaluation of Atoms

String and number atoms are evaluated by immediately returning the corresponding string or number
value. Symbols are treated as variables. See the subsection Variables for information on how these
are resolved.

** Variables

At any given point of evaluation (i.e. any time an expression is fed into the evaluator), there is
an associated *variable environment* which associates variable names to values. Variables in fn are
lexically scoped, which is to say that the variable environment has a hierarchical structure. The
top level of the hierarchy consists of all global variables, which are shared between top-level
expressions, while the lower levels correspond to the local variable environments introduced by ~let~
and ~fn~.

Variables in fn have symbols for names. Certain symbols are not legal as variable names. There is a
list in the Syntax section. Attempts to create variables with these names will result in an error at
compile time.

Global variables may be created with the ~def~ form:
#+BEGIN_SRC fn
(def NAME EXPR)
;; Defines a new global variable named NAME and set its value to the result
;; of evaluating EXPR. If there is already a global variable with this name, 
;; it is overwritten. Returns the new value.
;; - NAME is an unquoted symbol
;; - EXPR is an expression.
#+END_SRC

Global variables in fn are late-bound. That is to say, they may be referenced before their
definition. This allows definition of recursive functions. Attempts to access a nonexistent global
variable will result in a runtime error.

On the other hand, local variables may be created with the ~let~ form (note there are fewer
parentheses here than in most dialects of Lisp):

#+BEGIN_SRC fn
(let (VAR-1 EXPR-1
      VAR-2 EXPR-2
      ...
      VAR-N EXPR-N)
  BODY...)
;; Evaluates BODY... with new local variables. Creates local variables
;; VAR-1,...,VAR-N with values corresponding to the results of
;; EXPR-1,...,EXPR-N respectively. Returns the value of the last expression
;; in BODY.
;; - BODY... is a series of expressions
;; - VAR-i are symbols
;; - EXPR-i are expressions
#+END_SRC

The variable environment may be extended with a local variable whose name is already in use. In the
new environment, all references to that variable will resolve to the new variable in the shadowing
behavior typical of modern programming languages.

Currently, all variables in fn are mutable and may be updated using ~set~:
#+BEGIN_SRC fn
(set PLACE EXPR)
;; Updates the value of the variable or an object property denoted by PLACE
;; and returns the new value.
;; - PLACE is either a symbol name (for a variable) or a DOT form
;; - EXPR is the expression for the new value
#+END_SRC
The same local/global resolution rules are used here. ~set~ may not be used to define a new variable.

** Functions and Function Calls

A function call has the form

#+BEGIN_SRC fn
(FUNCTION ARGUMENTS* ... )
#+END_SRC

where FUNCTION is any expression other than one of the symbols identifying special forms. ARGUMENTS
may consist of anywhere from 0 to 255 expressions for arguments. (fn currently does not support
function calls with more than 255 arguments).

The expression for the function itself is evaluated first, followed by the arguments in the order in
whichthey appear (from left to right).

When a function is called, the variable environment in which it was defined is extended with the
function's parameters as local variables. (See Variables for resolution semantics). Thus every
function can be thought of as containing a reference to the environment in which it was defined. fn
has true closures, which is to say that even when multiple functions are defined in the same
environment, only one copy of that environment is made, so if a local variables is updated within
one such function, it will also have the new value when the other functions are called.

** Variable Resolution

When an unquoted symbol (other than true, false, or null) is encountered, it is first looked up as a
local variable. Local variables function with the typical lexical scoping rules where newly-defined
local variables can "shadow" those of the same name in a containing lexical scope.

Global variables in fn are late-bound and so are looked up by name. Thus the following code will
compile and run just fine:
#+BEGIN_SRC fn
(def get-my-global 
  (fn () my-global))
(def my-global 2.718)
(get-my-global)
#+END_SRC

Local variables are properly captured and saved by the ~fn~ operator where necessary.

When a function is called, its body
